{
  parserClass="org.elixir_lang.parser.ElixirParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Elixir"
  psiImplClassSuffix="Impl"
  psiPackage="org.elixir_lang.psi"
  psiImplPackage="org.elixir_lang.psi.impl"
  psiImplUtilClass="org.elixir_lang.psi.impl.ElixirPsiImplUtil"

  elementTypeHolderClass="org.elixir_lang.psi.ElixirTypes"
  elementTypeClass="org.elixir_lang.psi.ElixirElementType"
  tokenTypeClass="org.elixir_lang.psi.ElixirTokenType"

  tokens = [
    ALIAS_TOKEN = "Alias"
    AT_OPERATOR = "@"
    BASE_WHOLE_NUMBER_PREFIX = "0"
    BINARY_WHOLE_NUMBER_BASE = "b"
    CALL = ""
    CAPTURE_OPERATOR = "&"
    CHAR_LIST_HEREDOC_PROMOTER = "'''"
    CHAR_LIST_PROMOTER = "'"
    CHAR_TOKENIZER = "?"
    CLOSING_BRACKET = "]"
    // TODO remove once CLOSING_PARENTHESIS is used in emptyParentheses rule
    CLOSING_PARENTHESIS = ")"
    COLON = ":"
    COMMA = ","
    COMMENT = "regexp:#[^\r\n]*(\n|\r|\r\n)?"
    DECIMAL_MARK = "."
    DECIMAL_SEPARATOR = "_"
    DOT_OPERATOR = "."
    END = "end"
    FALSE = "false"
    FN = "fn"
    HEXADECIMAL_WHOLE_NUMBER_BASE = "x"
    IDENTIFIER = "identifier"
    IN_OPERATOR = "in"
    INVALID_BINARY_DIGITS = "regexp:[A-Za-z2-9]+"
    INVALID_UNKNOWN_BASE_DIGITS = "regexp:[A-Za-z0-9]+"
    NIL = "nil"
    OBSOLETE_BINARY_WHOLE_NUMBER_BASE = "B"
    OBSOLETE_HEXADECIMAL_WHOLE_NUMBER_BASE = "X"
    OCTAL_WHOLE_NUMBER_BASE = "o"
    OPENING_BRACKET = "["
    // TODO remove once OPENING_PARENTHESIS is used in emptyParentheses rule
    OPENING_PARENTHESIS = "("
    // TOO remove once SEMICOLON is used in endOfExpression rule
    SEMICOLON = ";"
    STRING_HEREDOC_PROMOTER = "\"\"\""
    STRING_PROMOTER = "\""
    // TODO remove once containers are available for `{}` after alias for empty structs
    STRUCT_OPERATOR = "%"
    TILDE = "~"
    TRUE = "true"
    TYPE_OPERATOR = "::"
    UNKNOWN_WHOLE_NUMBER_BASE = "regexp:A-Zac-z"
    VALID_BINARY_DIGITS = "regexp:[01]+"
    VALID_HEXADECIMAL_DIGITS = "regexp:[A-Fa-f0-9]+"
  ]
}

// expressionList is optional to handle code-less file that contains only EOL between blank lines and order comment
// lines
private elixirFile ::= endOfExpression* (expressionList endOfExpression*)?

/*
 *
 *
 * Expression List
 *
 *
 */

private infixSemicolon ::= EOL* SEMICOLON EOL*
// Must have at least one EOL or SEMICOLON, but at most one SEMICOLON
endOfExpression ::= infixSemicolon | EOL { implements = "org.elixir_lang.psi.Unquoted" }
private expression ::= emptyParentheses |
                       unqualifiedNoParenthesesManyArgumentsCall |
                       matchedExpression
private expressionList ::= expression (endOfExpression+ expression | adjacentExpression)*

/*
 *
 *
 * Function Calls
 *
 *
 */

/*
 *
 * No Parentheses
 *
 */

/*
 * Many Arguments
 */

private noParenthesesCommaExpression ::= matchedExpression (infixComma noParenthesesExpression)+
/* Have to prevent matchedExpression that is actually a keywordKey from being parsed as just a matchedExpression or
   callArgumentsNoParenthesesCommaExpression COMMA EOL* callArgumentsNoParenthesesKeywords will never match. */
noParenthesesExpression ::= emptyParentheses |
                            /* Must be before matchedExpression because noParenthesesExpression is
                               `matchedExpressionDotIdentifier callArgumentsNoParenthesesManyStrict` which is longer
                               than `matchedExpressionDotIdentifier` in matchedExpression. */
                            /* This will be marked as an error by
                               {@link org.elixir_lang.inspection.NoParenthesesManyStrict} */
                            noParenthesesManyStrictNoParenthesesExpression |
                            matchedExpression !KEYWORD_PAIR_COLON
                            { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
/* Special class for wrapping noParenthesesCall so that
   {@link: org.elixir_lang.inspection.NoParenthesesManyStrict} can just search for
   ElixirNoParenthesesManyStrictNoParenthesesExpression isn't of having to differentiate between valid and invalid
   ElixirNoParenthesesCall. */
noParenthesesManyStrictNoParenthesesExpression ::= unqualifiedNoParenthesesManyArgumentsCall
/* Special class for wrapping rules so that
   {@link: org.elixir_lang.inspection.NoParenthesesStrict} can just search for
   ElixirNoParenthesesStrict instead of having to differentiate between valid and invalid
   rule classes. */
noParenthesesStrict ::= emptyParentheses |
                        OPENING_PARENTHESIS (
                                             noParenthesesKeywords |
                                             noParenthesesManyArguments
                                            ) CLOSING_PARENTHESIS

noParenthesesFirstPositional ::= matchedExpression
                                 { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
noParenthesesOnePositionalAndKeywordsArguments ::= noParenthesesFirstPositional infixComma noParenthesesKeywords
                                                   { implements = "org.elixir_lang.psi.QuotableArguments" methods = [quoteArguments] }
noParenthesesManyPositionalAndMaybeKeywordsArguments ::= noParenthesesCommaExpression (infixComma noParenthesesKeywords)?
                                                         { implements = "org.elixir_lang.psi.QuotableArguments" methods = [quoteArguments] }

/* 1. (positional, keywords)
   2. (positional, positional)
   3. (positional, positional, keywords) */
noParenthesesManyArguments ::= noParenthesesOnePositionalAndKeywordsArguments |
                               noParenthesesManyPositionalAndMaybeKeywordsArguments
                               { implements = "org.elixir_lang.psi.QuotableArguments" methods = [quoteArguments] }
private noParenthesesManyArgumentsStrict ::= noParenthesesManyArguments |
                                             noParenthesesStrict

noParenthesesManyArgumentsUnqualifiedIdentifier ::= IDENTIFIER
                                                    { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L124-L125
unqualifiedNoParenthesesManyArgumentsCall ::= noParenthesesManyArgumentsUnqualifiedIdentifier
                                              noParenthesesManyArgumentsStrict
                                              {
                                                implements = "org.elixir_lang.psi.Call"
                                                methods = [
                                                  getArguments
                                                  getIdentifier
                                                  quote
                                                ]
                                              }

/*
 * 1+ Arguments
 */

noParenthesesKeywords ::= noParenthesesKeywordPair (infixComma noParenthesesKeywordPair)*
                          {
                            implements = "org.elixir_lang.psi.KeywordList"
                            methods = [
                              getKeywordPairList
                              quote
                            ]
                          }
noParenthesesKeywordPair ::= keywordKeyColonEOL noParenthesesExpression
                             {
                               implements = "org.elixir_lang.psi.KeywordPair"
                               methods = [
                                 getKeywordKey
                                 getKeywordValue
                                 quote
                               ]
                             }

/*
 * 0 Arguments
 */

noParenthesesNoArgumentsUnqualifiedCallOrVariable ::= IDENTIFIER
                                                       { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

/*
 *
 *
 * Heredoc
 *
 *
 */

heredocLinePrefix ::= HEREDOC_LINE_WHITE_SPACE_TOKEN? { methods = [excessWhitespace] }
heredocPrefix ::= HEREDOC_PREFIX_WHITE_SPACE?

/*
 *
 * Quote Heredocs
 *
 */

/*
 * CharList Heredoc
 */

charListHeredoc ::= CHAR_LIST_HEREDOC_PROMOTER EOL
                    interpolatedCharListHeredocLine*
                    heredocPrefix CHAR_LIST_HEREDOC_TERMINATOR
                    {
                      implements = [
                        "org.elixir_lang.psi.Heredoc"
                        "org.elixir_lang.psi.InterpolatedCharList"
                        "org.elixir_lang.psi.InterpolatedCharListHeredocLined"
                        "org.elixir_lang.psi.Quote"
                      ]
                      methods = [
                        addEscapedCharacterCodePoints
                        addFragmentCodePoints
                        addHexadecimalEscapeSequenceCodePoints
                        getFragmentType
                        getHeredocLineList
                        quote
                        quoteBinary
                        quoteEmpty
                        quoteLiteral
                      ]
                      pin = 1
                    }
interpolatedCharListHeredocLine ::= heredocLinePrefix interpolatedCharListBody EOL
                                    {
                                      implements = [
                                        "org.elixir_lang.psi.HeredocLine"
                                      ]
                                      methods = [
                                        getBody
                                        quote
                                      ]
                                    }

/*
 * String Heredoc
 */

stringHeredoc ::= STRING_HEREDOC_PROMOTER EOL
                  interpolatedStringHeredocLine*
                  heredocPrefix STRING_HEREDOC_TERMINATOR
                  {
                    implements = [
                      "org.elixir_lang.psi.Heredoc"
                      "org.elixir_lang.psi.InterpolatedString"
                    ]
                    methods = [
                      addEscapedCharacterCodePoints
                      addFragmentCodePoints
                      addHexadecimalEscapeSequenceCodePoints
                      getFragmentType
                      getHeredocLineList
                      quote
                      quoteBinary
                      quoteEmpty
                      quoteLiteral
                    ]
                    pin = 1
                  }
interpolatedStringHeredocLine ::= heredocLinePrefix interpolatedStringBody EOL
                                  {
                                    implements = [
                                      "org.elixir_lang.psi.HeredocLine"
                                    ]
                                    methods = [
                                      getBody
                                      quote
                                    ]
                                  }

/*
 *
 * Interpolated Sigil Heredocs
 *
 */

sigilModifiers ::= SIGIL_MODIFIER* { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

interpolatedCharListSigilHeredoc ::= TILDE INTERPOLATING_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_HEREDOC_PROMOTER EOL
                                     interpolatedCharListHeredocLine*
                                     heredocPrefix CHAR_LIST_SIGIL_HEREDOC_TERMINATOR sigilModifiers
                                     {
                                       implements = [
                                         "org.elixir_lang.psi.CharListFragmented"
                                         "org.elixir_lang.psi.InterpolatedCharListHeredocLined"
                                         "org.elixir_lang.psi.SigilHeredoc"
                                       ]
                                       methods = [
                                         addEscapedCharacterCodePoints
                                         addFragmentCodePoints
                                         addHexadecimalEscapeSequenceCodePoints
                                         getFragmentType
                                         getHeredocLineList
                                         quote
                                         quoteBinary
                                         quoteEmpty
                                         quoteLiteral
                                         sigilName
                                       ]
                                       pin = 3
                                     }

interpolatedRegexHeredoc ::= TILDE INTERPOLATING_REGEX_SIGIL_NAME REGEX_HEREDOC_PROMOTER EOL
                             interpolatedRegexHeredocLine*
                             heredocPrefix REGEX_HEREDOC_TERMINATOR sigilModifiers
                             {
                               implements = [
                                 "org.elixir_lang.psi.RegexFragmented"
                                 "org.elixir_lang.psi.SigilHeredoc"
                               ]
                               methods = [
                                 addEscapedCharacterCodePoints
                                 addFragmentCodePoints
                                 addHexadecimalEscapeSequenceCodePoints
                                 getFragmentType
                                 getHeredocLineList
                                 quote
                                 quoteBinary
                                 quoteEmpty
                                 quoteLiteral
                                 sigilName
                               ]
                               pin = 3
                             }
interpolatedRegexHeredocLine ::= heredocLinePrefix interpolatedRegexBody EOL
                                 {
                                   implements = [
                                     "org.elixir_lang.psi.HeredocLine"
                                   ]
                                   methods = [
                                     getBody
                                     quote
                                   ]
                                 }
interpolatedRegexBody ::= (interpolation | REGEX_FRAGMENT | escapeSequence)*
                          { implements = "org.elixir_lang.psi.Body" }

interpolatedSigilHeredoc ::= TILDE INTERPOLATING_SIGIL_NAME SIGIL_HEREDOC_PROMOTER EOL
                             interpolatedSigilHeredocLine*
                             heredocPrefix SIGIL_HEREDOC_TERMINATOR sigilModifiers
                             {
                               implements = [
                                 "org.elixir_lang.psi.SigilFragmented"
                                 "org.elixir_lang.psi.SigilHeredoc"
                               ]
                               methods = [
                                 addEscapedCharacterCodePoints
                                 addFragmentCodePoints
                                 addHexadecimalEscapeSequenceCodePoints
                                 getFragmentType
                                 getHeredocLineList
                                 quote
                                 quoteBinary
                                 quoteEmpty
                                 quoteLiteral
                                 sigilName
                               ]
                               pin = 3
                             }
interpolatedSigilHeredocLine ::= heredocLinePrefix interpolatedSigilBody EOL
                                 {
                                   implements = [
                                     "org.elixir_lang.psi.HeredocLine"
                                   ]
                                   methods = [
                                     getBody
                                     quote
                                   ]
                                 }
interpolatedSigilBody ::= (interpolation | SIGIL_FRAGMENT | escapeSequence)*
                          { implements = "org.elixir_lang.psi.Body" }

interpolatedStringSigilHeredoc ::= TILDE INTERPOLATING_STRING_SIGIL_NAME STRING_SIGIL_HEREDOC_PROMOTER EOL
                                     interpolatedStringHeredocLine*
                                     heredocPrefix STRING_SIGIL_HEREDOC_TERMINATOR sigilModifiers
                                     {
                                       implements = [
                                         "org.elixir_lang.psi.StringFragmented"
                                         "org.elixir_lang.psi.InterpolatedStringHeredocLined"
                                         "org.elixir_lang.psi.SigilHeredoc"
                                       ]
                                       methods = [
                                         addEscapedCharacterCodePoints
                                         addFragmentCodePoints
                                         addHexadecimalEscapeSequenceCodePoints
                                         getFragmentType
                                         getHeredocLineList
                                         quote
                                         quoteBinary
                                         quoteEmpty
                                         quoteLiteral
                                         sigilName
                                       ]
                                       pin = 3
                                     }

interpolatedWordsHeredoc ::= TILDE INTERPOLATING_WORDS_SIGIL_NAME WORDS_HEREDOC_PROMOTER EOL
                             interpolatedWordsHeredocLine*
                             heredocPrefix WORDS_HEREDOC_TERMINATOR sigilModifiers
                             {
                               implements = [
                                 "org.elixir_lang.psi.WordsFragmented"
                                 "org.elixir_lang.psi.SigilHeredoc"
                               ]
                               methods = [
                                 addEscapedCharacterCodePoints
                                 addFragmentCodePoints
                                 addHexadecimalEscapeSequenceCodePoints
                                 getFragmentType
                                 getHeredocLineList
                                 quote
                                 quoteBinary
                                 quoteEmpty
                                 quoteLiteral
                                 sigilName
                               ]
                               pin = 3
                             }
interpolatedWordsHeredocLine ::= heredocLinePrefix interpolatedWordsBody EOL
                                 {
                                   implements = [
                                     "org.elixir_lang.psi.HeredocLine"
                                   ]
                                   methods = [
                                     getBody
                                     quote
                                   ]
                                 }
interpolatedWordsBody ::= (interpolation | WORDS_FRAGMENT | escapeSequence)*
                          { implements = "org.elixir_lang.psi.Body" }

/*
 * Literal Sigil Heredocs
 */

literalCharListSigilHeredoc ::= TILDE LITERAL_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_HEREDOC_PROMOTER EOL
                                literalCharListHeredocLine*
                                heredocPrefix CHAR_LIST_SIGIL_HEREDOC_TERMINATOR sigilModifiers
                                {
                                  implements = [
                                    "org.elixir_lang.psi.CharListFragmented"
                                    "org.elixir_lang.psi.SigilHeredoc"
                                  ]
                                  methods = [
                                    addEscapedCharacterCodePoints
                                    addFragmentCodePoints
                                    addHexadecimalEscapeSequenceCodePoints
                                    getFragmentType
                                    getHeredocLineList
                                    quote
                                    quoteBinary
                                    quoteEmpty
                                    quoteLiteral
                                    sigilName
                                  ]
                                  pin = 3
                                }
literalCharListHeredocLine ::= heredocLinePrefix literalCharListBody EOL
                               {
                                 implements = [
                                   "org.elixir_lang.psi.HeredocLine"
                                 ]
                                 methods = [
                                   getBody
                                   quote
                                 ]
                               }
literalCharListBody ::= CHAR_LIST_FRAGMENT*
                        { implements = "org.elixir_lang.psi.Body" }

literalRegexHeredoc ::= TILDE LITERAL_REGEX_SIGIL_NAME REGEX_HEREDOC_PROMOTER EOL
                        literalRegexHeredocLine*
                        heredocPrefix REGEX_HEREDOC_TERMINATOR sigilModifiers
                        {
                          implements = [
                            "org.elixir_lang.psi.RegexFragmented"
                            "org.elixir_lang.psi.SigilHeredoc"
                          ]
                          methods = [
                            addEscapedCharacterCodePoints
                            addFragmentCodePoints
                            addHexadecimalEscapeSequenceCodePoints
                            getFragmentType
                            getHeredocLineList
                            quote
                            quoteBinary
                            quoteEmpty
                            quoteLiteral
                            sigilName
                          ]
                          pin = 3
                        }
literalRegexHeredocLine ::= heredocLinePrefix literalRegexBody EOL
                            {
                              implements = [
                                "org.elixir_lang.psi.HeredocLine"
                              ]
                              methods = [
                                getBody
                                quote
                              ]
                            }
literalRegexBody ::= REGEX_FRAGMENT*
                     { implements = "org.elixir_lang.psi.Body" }

literalSigilHeredoc ::= TILDE LITERAL_SIGIL_NAME SIGIL_HEREDOC_PROMOTER EOL
                        literalSigilHeredocLine*
                        heredocPrefix SIGIL_HEREDOC_TERMINATOR sigilModifiers
                        {
                          implements = [
                            "org.elixir_lang.psi.SigilFragmented"
                            "org.elixir_lang.psi.SigilHeredoc"
                          ]
                          methods = [
                            addEscapedCharacterCodePoints
                            addFragmentCodePoints
                            addHexadecimalEscapeSequenceCodePoints
                            getFragmentType
                            getHeredocLineList
                            quote
                            quoteBinary
                            quoteEmpty
                            quoteLiteral
                            sigilName
                          ]
                          pin = 3
                        }
literalSigilHeredocLine ::= heredocLinePrefix literalSigilBody EOL
                            {
                              implements = [
                                "org.elixir_lang.psi.HeredocLine"
                              ]
                              methods = [
                                getBody
                                quote
                              ]
                            }
literalSigilBody ::= SIGIL_FRAGMENT*
                     { implements = "org.elixir_lang.psi.Body" }
                     
literalStringSigilHeredoc ::= TILDE LITERAL_STRING_SIGIL_NAME STRING_SIGIL_HEREDOC_PROMOTER EOL
                              literalStringHeredocLine*
                              heredocPrefix STRING_SIGIL_HEREDOC_TERMINATOR sigilModifiers
                              {
                                implements = [
                                  "org.elixir_lang.psi.StringFragmented"
                                  "org.elixir_lang.psi.SigilHeredoc"
                                ]
                                methods = [
                                  addEscapedCharacterCodePoints
                                  addFragmentCodePoints
                                  addHexadecimalEscapeSequenceCodePoints
                                  getFragmentType
                                  getHeredocLineList
                                  quote
                                  quoteBinary
                                  quoteEmpty
                                  quoteLiteral
                                  sigilName
                                ]
                                pin = 3
                              }
literalStringHeredocLine ::= heredocLinePrefix literalStringBody EOL
                             {
                               implements = [
                                 "org.elixir_lang.psi.HeredocLine"
                               ]
                               methods = [
                                 getBody
                                 quote
                               ]
                             }
literalStringBody ::= STRING_FRAGMENT*
                      { implements = "org.elixir_lang.psi.Body" }
                      
literalWordsHeredoc ::= TILDE LITERAL_WORDS_SIGIL_NAME WORDS_HEREDOC_PROMOTER EOL
                        literalWordsHeredocLine*
                        heredocPrefix WORDS_HEREDOC_TERMINATOR sigilModifiers
                        {
                          implements = [
                            "org.elixir_lang.psi.WordsFragmented"
                            "org.elixir_lang.psi.SigilHeredoc"
                          ]
                          methods = [
                            addEscapedCharacterCodePoints
                            addFragmentCodePoints
                            addHexadecimalEscapeSequenceCodePoints
                            getFragmentType
                            getHeredocLineList
                            quote
                            quoteBinary
                            quoteEmpty
                            quoteLiteral
                            sigilName
                          ]
                          pin = 3
                        }
literalWordsHeredocLine ::= heredocLinePrefix literalWordsBody EOL
                            {
                              implements = [
                                "org.elixir_lang.psi.HeredocLine"
                              ]
                              methods = [
                                getBody
                                quote
                              ]
                            }
literalWordsBody ::= WORDS_FRAGMENT*
                     { implements = "org.elixir_lang.psi.Body" }

/*
 *
 *
 * Lines (as opposed to Heredocs)
 *
 *
 */

/*
 *
 * Quote Lines
 *
 */


interpolatedCharListBody ::= (interpolation | CHAR_LIST_FRAGMENT | escapeSequence)*
                             { implements =  "org.elixir_lang.psi.Body" }
charListLine ::= CHAR_LIST_PROMOTER interpolatedCharListBody CHAR_LIST_TERMINATOR
                 {
                   implements = [
                     "org.elixir_lang.psi.Atomable"
                     "org.elixir_lang.psi.InterpolatedCharList"
                     "org.elixir_lang.psi.Quotable"
                   ]
                   methods = [
                     addEscapedCharacterCodePoints
                     addFragmentCodePoints
                     addHexadecimalEscapeSequenceCodePoints
                     getFragmentType
                     quote
                     quoteAsAtom
                     quoteBinary
                     quoteEmpty
                     quoteLiteral
                   ]
                 }

interpolatedStringBody ::=  (interpolation | STRING_FRAGMENT | escapeSequence)*
                            { implements = "org.elixir_lang.psi.Body" }
stringLine ::= STRING_PROMOTER
               interpolatedStringBody
               STRING_TERMINATOR
               {
                 implements = [
                   "org.elixir_lang.psi.Atomable"
                   "org.elixir_lang.psi.InterpolatedString"
                   "org.elixir_lang.psi.Quotable"
                 ]
                 methods = [
                   addEscapedCharacterCodePoints
                   addFragmentCodePoints
                   addHexadecimalEscapeSequenceCodePoints
                   getFragmentType
                   quote
                   quoteAsAtom
                   quoteBinary
                   quoteEmpty
                   quoteLiteral
                 ]
               }

/*
 *
 * Sigil Lines
 *
 */

/*
 * Interpolated Sigil Lines
 */

interpolatedCharListSigilLine ::= TILDE INTERPOLATING_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_PROMOTER interpolatedCharListBody CHAR_LIST_SIGIL_TERMINATOR sigilModifiers
                                  {
                                    implements = [
                                      "org.elixir_lang.psi.CharListFragmented"
                                      "org.elixir_lang.psi.SigilLine"
                                    ]
                                    methods = [
                                      addEscapedCharacterCodePoints
                                      addFragmentCodePoints
                                      addHexadecimalEscapeSequenceCodePoints
                                      getBody
                                      getFragmentType
                                      quote
                                      quoteBinary
                                      quoteEmpty
                                      quoteLiteral
                                      sigilName
                                    ]
                                  }

interpolatedRegexLine ::= TILDE INTERPOLATING_REGEX_SIGIL_NAME REGEX_PROMOTER interpolatedRegexBody REGEX_TERMINATOR sigilModifiers
                          {
                            implements = [
                              "org.elixir_lang.psi.RegexFragmented"
                              "org.elixir_lang.psi.SigilLine"
                            ]
                            methods = [
                              addEscapedCharacterCodePoints
                              addFragmentCodePoints
                              addHexadecimalEscapeSequenceCodePoints
                              getBody
                              getFragmentType
                              quote
                              quoteBinary
                              quoteEmpty
                              quoteLiteral
                              sigilName
                            ]
                          }

interpolatedSigilLine ::= TILDE INTERPOLATING_SIGIL_NAME SIGIL_PROMOTER interpolatedSigilBody SIGIL_TERMINATOR sigilModifiers
                          {
                            implements = [
                              "org.elixir_lang.psi.SigilFragmented"
                              "org.elixir_lang.psi.SigilLine"
                            ]
                            methods = [
                              addEscapedCharacterCodePoints
                              addFragmentCodePoints
                              addHexadecimalEscapeSequenceCodePoints
                              getBody
                              getFragmentType
                              quote
                              quoteBinary
                              quoteEmpty
                              quoteLiteral
                              sigilName
                            ]
                          }

interpolatedStringSigilLine ::= TILDE INTERPOLATING_STRING_SIGIL_NAME STRING_SIGIL_PROMOTER interpolatedStringBody STRING_SIGIL_TERMINATOR sigilModifiers
                                {
                                  implements = [
                                    "org.elixir_lang.psi.StringFragmented"
                                    "org.elixir_lang.psi.SigilLine"
                                  ]
                                  methods = [
                                    addEscapedCharacterCodePoints
                                    addFragmentCodePoints
                                    addHexadecimalEscapeSequenceCodePoints
                                    getBody
                                    getFragmentType
                                    quote
                                    quoteBinary
                                    quoteEmpty
                                    quoteLiteral
                                    sigilName
                                  ]
                                }

interpolatedWordsLine ::= TILDE INTERPOLATING_WORDS_SIGIL_NAME WORDS_PROMOTER interpolatedWordsBody WORDS_TERMINATOR sigilModifiers
                          {
                            implements = [
                              "org.elixir_lang.psi.WordsFragmented"
                              "org.elixir_lang.psi.SigilLine"
                            ]
                            methods = [
                              addEscapedCharacterCodePoints
                              addFragmentCodePoints
                              addHexadecimalEscapeSequenceCodePoints
                              getBody
                              getFragmentType
                              quote
                              quoteBinary
                              quoteEmpty
                              quoteLiteral
                              sigilName
                            ]
                          }
/*
 * Literal Sigils
 */

literalCharListSigilLine ::= TILDE LITERAL_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_PROMOTER literalCharListBody CHAR_LIST_SIGIL_TERMINATOR sigilModifiers
                             {
                               implements = [
                                 "org.elixir_lang.psi.CharListFragmented"
                                 "org.elixir_lang.psi.SigilLine"
                               ]
                               methods = [
                                 addEscapedCharacterCodePoints
                                 addFragmentCodePoints
                                 addHexadecimalEscapeSequenceCodePoints
                                 getBody
                                 getFragmentType
                                 quote
                                 quoteBinary
                                 quoteEmpty
                                 quoteLiteral
                                 sigilName
                               ]
                             }

literalRegexLine ::= TILDE LITERAL_REGEX_SIGIL_NAME REGEX_PROMOTER literalRegexBody REGEX_TERMINATOR sigilModifiers
                     {
                       implements = [
                         "org.elixir_lang.psi.RegexFragmented"
                         "org.elixir_lang.psi.SigilLine"
                       ]
                       methods = [
                         addEscapedCharacterCodePoints
                         addFragmentCodePoints
                         addHexadecimalEscapeSequenceCodePoints
                         getBody
                         getFragmentType
                         quote
                         quoteBinary
                         quoteEmpty
                         quoteLiteral
                         sigilName
                       ]
                     }

literalSigilLine ::= TILDE LITERAL_SIGIL_NAME SIGIL_PROMOTER literalSigilBody SIGIL_TERMINATOR sigilModifiers
                     {
                       implements = [
                         "org.elixir_lang.psi.SigilFragmented"
                         "org.elixir_lang.psi.SigilLine"
                       ]
                       methods = [
                         addEscapedCharacterCodePoints
                         addFragmentCodePoints
                         addHexadecimalEscapeSequenceCodePoints
                         getBody
                         getFragmentType
                         quote
                         quoteBinary
                         quoteEmpty
                         quoteLiteral
                         sigilName
                       ]
                     }

literalStringSigilLine ::= TILDE LITERAL_STRING_SIGIL_NAME STRING_SIGIL_PROMOTER literalStringBody STRING_SIGIL_TERMINATOR sigilModifiers
                           {
                             implements = [
                               "org.elixir_lang.psi.StringFragmented"
                               "org.elixir_lang.psi.SigilLine"
                             ]
                             methods = [
                               addEscapedCharacterCodePoints
                               addFragmentCodePoints
                               addHexadecimalEscapeSequenceCodePoints
                               getBody
                               getFragmentType
                               quote
                               quoteBinary
                               quoteEmpty
                               quoteLiteral
                               sigilName
                             ]
                           }

literalWordsLine ::=  TILDE LITERAL_WORDS_SIGIL_NAME WORDS_PROMOTER literalWordsBody WORDS_TERMINATOR sigilModifiers
                      {
                        implements = [
                          "org.elixir_lang.psi.WordsFragmented"
                          "org.elixir_lang.psi.SigilLine"
                        ]
                        methods = [
                          addEscapedCharacterCodePoints
                          addFragmentCodePoints
                          addHexadecimalEscapeSequenceCodePoints
                          getBody
                          getFragmentType
                          quote
                          quoteBinary
                          quoteEmpty
                          quoteLiteral
                          sigilName
                        ]
                      }

/*
 *
 *
 * Matched Expressions - ordered by outer-most (lowest precedence) to inner-most (highest precedence)
 *
 * See ELIXIR_BNF_DESIGN.md for exanplanation of the naming and nesting pattern used in the matchedExpression rules.
 *
 *
 */

private matchedExpression ::= matchedCaptureNonNumericExpression

/*
 * Capture Non-Numeric Operation - non-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L50
 *
 */

capturePrefixOperator ::= CAPTURE_OPERATOR EOL*
                          {
                            implements = "org.elixir_lang.psi.Operator"
                            methods = [
                              operatorTokenSet
                              quote
                            ]
                            name = "&"
                          }
private matchedCaptureNonNumericExpression ::= matchedCaptureNonNumericOperation |
                                               matchedCaptureNonNumericOperand
private matchedCaptureNonNumericOperand ::= matchedCaptureNonNumericOperation |
                                            matchedInMatchExpression
matchedCaptureNonNumericOperation ::= capturePrefixOperator !numeric matchedCaptureNonNumericOperand
                                      { implements = "org.elixir_lang.psi.PrefixOperation" methods = [quote] }

/*
 * In Match Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L51
 */

inMatchInfixOperator ::= EOL* IN_MATCH_OPERATOR EOL*
                    {
                      implements = "org.elixir_lang.psi.Operator"
                      methods = [
                        operatorTokenSet
                        quote
                      ]
                      name = "<-, \\\\"
                    }
private matchedInMatchExpression ::= matchedInMatchOperand matchedInMatchOperation*
private matchedInMatchOperand ::= matchedCaptureNonNumericOperation |
                                  matchedWhenExpression
left matchedInMatchOperation ::= inMatchInfixOperator matchedInMatchOperand
                                 { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] }

/*
 * When Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L52
 */

whenInfixOperator ::= EOL* WHEN_OPERATOR EOL*
                      {
                        implements = "org.elixir_lang.psi.Operator"
                        methods = [
                          operatorTokenSet
                          quote
                        ]
                        name = "when"
                      }
private matchedWhenExpression ::= matchedWhenOperand matchedWhenOperation?
private matchedWhenOperand ::= matchedCaptureNonNumericOperation |
                               // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L173
                               noParenthesesKeywords |
                               matchedTypeExpression
left matchedWhenOperation ::= whenInfixOperator matchedWhenExpression
                              { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] }

/*
 * Type Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L53
 */

typeInfixOperator ::= EOL* TYPE_OPERATOR EOL*
                      {
                        implements = "org.elixir_lang.psi.Operator"
                        methods = [
                          operatorTokenSet
                          quote
                        ]
                        name = "::"
                      }
private matchedTypeExpression ::= matchedTypeOperand matchedTypeOperation?
private matchedTypeOperand ::= matchedCaptureNonNumericOperation |
                               matchedPipeExpression
left matchedTypeOperation ::= typeInfixOperator matchedTypeExpression
                               { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] }
/*
 * Pipe Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L54
 */

pipeInfixOperator ::= EOL* PIPE_OPERATOR EOL*
                      {
                        implements = "org.elixir_lang.psi.Operator"
                        methods = [
                          operatorTokenSet
                          quote
                        ]
                        name = "|"
                      }
private matchedPipeExpression ::= matchedPipeOperand matchedPipeOperation?
private matchedPipeOperand ::= matchedCaptureNonNumericOperation |
                               matchedMatchExpression
left matchedPipeOperation ::= pipeInfixOperator matchedPipeExpression
                               { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] }

/*
 * Match Operation - right-associative
 *
 * @see see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L56
 */

matchInfixOperator ::= EOL* MATCH_OPERATOR EOL*
                       {
                         implements = "org.elixir_lang.psi.Operator"
                         methods = [
                           operatorTokenSet
                           quote
                         ]
                         name = "="
                       }
private matchedMatchExpression ::= matchedMatchOperand matchedMatchOperation?
private matchedMatchOperand ::= matchedCaptureNonNumericOperation |
                                matchedOrExpression
left matchedMatchOperation ::= matchInfixOperator matchedMatchExpression
                               { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] }

/*
 * Or Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L57
 */

orInfixOperator ::= EOL* OR_OPERATOR EOL*
                    {
                      implements = "org.elixir_lang.psi.Operator"
                      methods = [
                        operatorTokenSet
                        quote
                      ]
                      name = "||, |||, or"
                    }
private matchedOrExpression ::= matchedOrOperand matchedOrOperation*
private matchedOrOperand ::= matchedCaptureNonNumericOperation |
                             matchedAndExpression
left matchedOrOperation ::= orInfixOperator matchedOrOperand
                            { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] }

/*
 * And Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L58
 */
andInfixOperator ::= EOL* AND_OPERATOR EOL*
                     {
                       implements = "org.elixir_lang.psi.Operator"
                       methods = [
                         operatorTokenSet
                         quote
                       ]
                       name = "&&, &&&, and"
                     }
private matchedAndExpression ::= matchedAndOperand matchedAndOperation*
private matchedAndOperand ::= matchedCaptureNonNumericOperation |
                              matchedComparisonExpression
left matchedAndOperation ::= andInfixOperator matchedAndOperand
                             { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] }

/*
 * Comparison Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L59
 */

comparisonInfixOperator ::= EOL* COMPARISON_OPERATOR EOL*
                            {
                              implements = "org.elixir_lang.psi.Operator"
                              methods = [
                                operatorTokenSet
                                quote
                              ]
                              name = "!=, ==, =~, !==, ==="
                            }
private matchedComparisonExpression ::= matchedComparisonOperand matchedComparisonOperation*
private matchedComparisonOperand ::= matchedCaptureNonNumericOperation |
                                     matchedRelationalExpression
left matchedComparisonOperation ::= comparisonInfixOperator matchedComparisonOperand
                                    { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] }

/*
 * Relational Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L60
 */

relationalInfixOperator ::= EOL* RELATIONAL_OPERATOR EOL*
                            {
                              implements = "org.elixir_lang.psi.Operator"
                              methods = [
                                operatorTokenSet
                                quote
                              ]
                              name = "<, >, <=, >="
                            }
private matchedRelationalExpression ::= matchedRelationalOperand matchedRelationalOperation*
private matchedRelationalOperand ::= matchedCaptureNonNumericOperation |
                                     matchedArrowExpression
left matchedRelationalOperation ::= relationalInfixOperator matchedRelationalOperand
                                    { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] }

/*
 * Arrow Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L61
 */

arrowInfixOperator ::= EOL* ARROW_OPERATOR EOL*
                       {
                         implements = "org.elixir_lang.psi.Operator"
                         methods = [
                           operatorTokenSet
                           quote
                         ]
                         name = "<~, |>, ~>, <<<, <<~, <|>, <~>, >>>, ~>>"
                       }
private matchedArrowExpression ::= matchedArrowOperand matchedArrowOperation*
private matchedArrowOperand ::= matchedCaptureNonNumericOperation |
                                matchedInExpression
left matchedArrowOperation ::= arrowInfixOperator matchedArrowOperand
                               { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] }
/*
 * In Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L62
 */

inInfixOperator ::= EOL* IN_OPERATOR EOL*
                    {
                      implements = "org.elixir_lang.psi.Operator"
                      methods = [
                        operatorTokenSet
                        quote
                      ]
                      name = "in"
                    }
private matchedInExpression ::= matchedInOperand matchedInOperation*
private matchedInOperand ::= matchedCaptureNonNumericOperation |
                             matchedTwoExpression
left matchedInOperation ::= inInfixOperator matchedInOperand
                            { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] }

/*
 * Two Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L63
 */

twoInfixOperator ::= EOL* TWO_OPERATOR EOL*
                     {
                       implements = "org.elixir_lang.psi.Operator"
                       methods = [
                         operatorTokenSet
                         quote
                       ]
                       name = "++, --, .., <>"
                     }
private matchedTwoExpression ::= matchedTwoOperand matchedTwoOperation?
private matchedTwoOperand ::= matchedCaptureNonNumericOperation |
                              matchedAdditionExpression
left matchedTwoOperation ::= twoInfixOperator matchedTwoExpression
                             { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] }
/*
 * Addition Operation
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L64
 *
 */

// left-associative
/* Unlike other binary operation, additionOperations cannot begin with EOLs: if there are EOLs, then the +/- is
   interpreted as unaryOperation */
additionInfixOperator ::= DUAL_OPERATOR EOL*
                          {
                            implements = "org.elixir_lang.psi.Operator"
                            methods = [
                              operatorTokenSet
                              quote
                            ]
                            name = "+, -"
                          }
private matchedAdditionExpression ::= matchedAdditionOperand matchedAdditionOperation*
private matchedAdditionOperand ::= matchedCaptureNonNumericOperation |
                                   matchedMultiplicationExpression
left matchedAdditionOperation ::= additionInfixOperator matchedAdditionOperand
                                  { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] }


/*
 * Multiplication Operation
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L65
 *
 */

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L65)
multiplicationInfixOperator ::= EOL* MULTIPLICATION_OPERATOR EOL*
                                {
                                  implements = "org.elixir_lang.psi.Operator"
                                  methods = [
                                    operatorTokenSet
                                    quote
                                  ]
                                  name = "*, /"
                                }
private matchedMultiplicationExpression ::= matchedMultiplicationOperand matchedMultiplicationOperation*
private matchedMultiplicationOperand ::= matchedCaptureNonNumericOperation |
                                         matchedHatExpression
left matchedMultiplicationOperation ::= multiplicationInfixOperator matchedMultiplicationOperand
                                        { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] }

/*
 * Hat Operation
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L66
 *
 */

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L66)
hatInfixOperator ::= EOL* HAT_OPERATOR EOL*
                     {
                       implements = "org.elixir_lang.psi.Operator"
                       methods = [
                         operatorTokenSet
                         quote
                       ]
                       name = "^^^"
                     }
private matchedHatExpression ::= matchedHatOperand matchedHatOperation*
private matchedHatOperand ::= matchedCaptureNonNumericOperation |
                              matchedUnaryNonNumericExpression
left matchedHatOperation ::= hatInfixOperator matchedHatOperand
                             { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] }

/*
 * Non-Numeric Unary Operation
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L67
 *
 */

// non-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L67)
unaryPrefixOperator ::= (DUAL_OPERATOR | UNARY_OPERATOR) EOL*
                        {
                          implements = "org.elixir_lang.psi.Operator"
                          methods = [
                            operatorTokenSet
                            quote
                          ]
                          name = "+, -, !, ^, not, ~~~"
                        }
private matchedUnaryNonNumericExpression ::= matchedUnaryNonNumericOperation |
                                             matchedUnaryNonNumericOperand
private matchedUnaryNonNumericOperand ::= matchedCaptureNonNumericOperation |
                                          matchedUnaryNonNumericOperation |
                                          matchedDotExpression
matchedUnaryNonNumericOperation ::= unaryPrefixOperator !numeric matchedUnaryNonNumericOperand
                                    { implements = "org.elixir_lang.psi.PrefixOperation" methods = [quote] }

/*
 * Dot Operation
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L69
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L71
 *
 */

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L69)
dotInfixOperator ::= EOL* DOT_OPERATOR EOL*
                     {
                       implements = "org.elixir_lang.psi.Operator"
                       name = "."
                       methods = [
                         operatorTokenSet
                         quote
                       ]
                     }
private matchedDotExpression ::= matchedDotOperand matchedDotOperation*
private matchedDotOperand ::= matchedCaptureNonNumericOperation |
                              matchedUnaryNonNumericOperation |
                              matchedAtNonNumericExpression
left matchedDotOperation ::= dotInfixOperator !(atom | charListHeredoc | stringHeredoc | numeric) matchedDotOperand
                             { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] }

/*
 * Non-Numeric At Operation
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L70
 *
 */

// non-associative (https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L70)
atPrefixOperator ::= AT_OPERATOR EOL*
                     {
                       implements = "org.elixir_lang.psi.Operator"
                       methods = [
                         operatorTokenSet
                         quote
                       ]
                       name = "@"
                     }
private matchedAtNonNumericExpression ::= matchedAtNonNumericOperation |
                                          matchedAtNonNumericOperand
private matchedAtNonNumericOperand ::= matchedCaptureNonNumericOperation |
                                       matchedUnaryNonNumericOperation |
                                       matchedAtNonNumericOperation |
                                       matchedCallExpression
matchedAtNonNumericOperation ::= atPrefixOperator !numeric matchedAtNonNumericOperand
                                 { implements = "org.elixir_lang.psi.PrefixOperation" methods = [quote] }

/*
 * Calls
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L71
 */

private matchedCallExpression ::= matchedCallOperand matchedCallOperation?
private matchedCallOperand ::= matchedCaptureNonNumericOperation |
                               matchedUnaryNonNumericOperation |
                               matchedAtNonNumericOperation |
                               noParenthesesNoArgumentsUnqualifiedCallOrVariable |
                               accessExpression
/*
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L125
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L125
 */
left matchedCallOperation ::= noParenthesesManyArgumentsStrict
                              {
                                implements = "org.elixir_lang.psi.Call"
                                methods = [
                                  getArguments
                                  getIdentifier
                                  quote
                                ]
                              }

/*
 * Access expression
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L200-L223
 *
 */

atNumericOperation ::= atPrefixOperator numeric
                       { implements = "org.elixir_lang.psi.PrefixOperation" methods = [quote] }
captureNumericOperation ::= capturePrefixOperator numeric
                            { implements = "org.elixir_lang.psi.PrefixOperation" methods = [quote] }
unaryNumericOperation ::= unaryPrefixOperator numeric
                          { implements = "org.elixir_lang.psi.PrefixOperation" methods = [quote] }

emptyBlock ::= OPENING_PARENTHESIS infixSemicolon CLOSING_PARENTHESIS
               { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

private accessExpression ::= atNumericOperation |
                             captureNumericOperation |
                             unaryNumericOperation |
                             emptyBlock |
                             numeric |
                             list |
                             stringLine |
                             stringHeredoc |
                             charListLine |
                             charListHeredoc |
                             interpolatedCharListSigilLine |
                             interpolatedCharListSigilHeredoc |
                             interpolatedRegexHeredoc |
                             interpolatedSigilHeredoc |
                             interpolatedStringSigilHeredoc |
                             interpolatedWordsHeredoc |
                             interpolatedWordsLine |
                             interpolatedRegexLine |
                             interpolatedSigilLine |
                             interpolatedStringSigilLine |
                             literalCharListSigilLine |
                             literalCharListSigilHeredoc |
                             literalRegexHeredoc |
                             literalSigilHeredoc |
                             literalStringSigilHeredoc |
                             literalWordsHeredoc |
                             literalRegexLine |
                             literalSigilLine |
                             literalStringSigilLine |
                             literalWordsLine |
                             atomKeyword |
                             atom |
                             alias

// keywords that map to atoms
atomKeyword ::= FALSE | NIL | TRUE
                { implements = "org.elixir_lang.psi.Quotable" methods = [quote] name = "false, nil, true" }

alias ::= ALIAS_TOKEN
          { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

/*
 *
 *
 * Whole Numbers
 *
 *
 *
 */

decimalDigits ::= INVALID_DECIMAL_DIGITS | VALID_DECIMAL_DIGITS
                  { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
decimalWholeNumber ::= decimalDigits (DECIMAL_SEPARATOR? decimalDigits)*
                        {
                          implements = "org.elixir_lang.psi.WholeNumber"
                          methods = [
                            base
                            digitsList
                            quote
                          ]
                        }

/*
 *
 * Base (Non-Decimal) Whole Numbers
 *
 */

/*
 * Binary (2)
 */

binaryDigits ::= INVALID_BINARY_DIGITS | VALID_BINARY_DIGITS
                 { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
binaryWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX (BINARY_WHOLE_NUMBER_BASE | OBSOLETE_BINARY_WHOLE_NUMBER_BASE) binaryDigits+
                     {
                       implements = "org.elixir_lang.psi.WholeNumber"
                       methods = [
                         base
                         digitsList
                         quote
                       ]
                       pin = 2
                     }

/*
 * Hexadecimal (16)
 */

hexadecimalDigits ::= INVALID_HEXADECIMAL_DIGITS | VALID_HEXADECIMAL_DIGITS
                      { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
hexadecimalWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX (HEXADECIMAL_WHOLE_NUMBER_BASE | OBSOLETE_HEXADECIMAL_WHOLE_NUMBER_BASE) hexadecimalDigits+
                           {
                             implements = "org.elixir_lang.psi.WholeNumber"
                             methods = [
                               base
                               digitsList
                               quote
                             ]
                             pin = 2
                           }

/*
 * Octal (8)
 */

octalDigits ::= INVALID_OCTAL_DIGITS | VALID_OCTAL_DIGITS
                { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
octalWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX OCTAL_WHOLE_NUMBER_BASE octalDigits+
                     {
                       implements = "org.elixir_lang.psi.WholeNumber"
                       methods = [
                         base
                         digitsList
                         quote
                       ]
                       pin = 2
                     }

/*
 * Unknown (1-36)
 */

unknownBaseDigits ::= INVALID_UNKNOWN_BASE_DIGITS
                      { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
unknownBaseWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX UNKNOWN_WHOLE_NUMBER_BASE unknownBaseDigits+
                           {
                             implements = "org.elixir_lang.psi.WholeNumber"
                             methods = [
                               base
                               digitsList
                               quote
                             ]
                             pin=2
                           }

/*
 *
 *
 * In alphabetical order
 *
 *
 */

// an expression in an expressionList that is NOT preceded by endOfExpression(s)
adjacentExpression ::= expression
                       { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
atom ::= COLON (ATOM_FRAGMENT | quote)
         { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

private infixComma ::= COMMA EOL*

charToken ::= CHAR_TOKENIZER (CHAR_LIST_FRAGMENT | escapeSequence)
              { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

private containerExpression ::= emptyParentheses

decimalFloat ::= decimalFloatIntegral DECIMAL_MARK decimalFloatFractional (EXPONENT_MARK decimalFloatExponent)?
                 { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
decimalFloatExponent ::= decimalFloatExponentSign decimalWholeNumber
decimalFloatExponentSign ::= DUAL_OPERATOR?
decimalFloatFractional ::= decimalWholeNumber
decimalFloatIntegral ::= decimalWholeNumber

private escapeSequence ::= hexadecimalEscapeSequence |
                           escapedEOL |
                           /* Must be last so that ESCAPE ('\') can be pinned in escapedCharacter without excluding
                              ("\x") in hexadecimalEscapeSequence  */
                           escapedCharacter
hexadecimalEscapeSequence ::= ESCAPE HEXADECIMAL_WHOLE_NUMBER_BASE (openHexadecimalEscapeSequence | enclosedHexadecimalEscapeSequence)
                              {
                                implements = "org.elixir_lang.psi.EscapeSequence"
                                methods = [codePoint]
                                pin = 2
                              }
enclosedHexadecimalEscapeSequence ::= OPENING_CURLY VALID_HEXADECIMAL_DIGITS CLOSING_CURLY
                                      { implements = "org.elixir_lang.psi.EscapedHexadecimalDigits" methods = [codePoint] pin = 1 }
openHexadecimalEscapeSequence ::= VALID_HEXADECIMAL_DIGITS
                                  { implements = "org.elixir_lang.psi.EscapedHexadecimalDigits" methods = [codePoint] }
escapedCharacter ::= ESCAPE ESCAPED_CHARACTER_TOKEN
                     { implements = "org.elixir_lang.psi.EscapeSequence" methods = [codePoint] pin = 1 }
escapedEOL ::= ESCAPE EOL
               { implements = "org.elixir_lang.psi.EscapeSequence" methods = [codePoint] }
emptyParentheses ::= OPENING_PARENTHESIS EOL* CLOSING_PARENTHESIS
                     { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
interpolation ::= INTERPOLATION_START elixirFile INTERPOLATION_END
                  { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
keywordKey ::= ALIAS_TOKEN |
               AND_OPERATOR |
               ARROW_OPERATOR |
               ASSOCIATION_OPERATOR |
               AT_OPERATOR |
               BIT_STRING_OPERATOR |
               CAPTURE_OPERATOR |
               COMPARISON_OPERATOR |
               DUAL_OPERATOR |
               HAT_OPERATOR |
               IDENTIFIER |
               IN_MATCH_OPERATOR |
               IN_OPERATOR |
               MAP_OPERATOR |
               MATCH_OPERATOR |
               MULTIPLICATION_OPERATOR |
               OR_OPERATOR |
               PIPE_OPERATOR |
               RELATIONAL_OPERATOR |
               STAB_OPERATOR |
               STRUCT_OPERATOR |
               TUPLE_OPERATOR |
               TWO_OPERATOR |
               UNARY_OPERATOR |
               WHEN_OPERATOR |
               quote
               { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
private keywordKeyColonEOL ::= keywordKey KEYWORD_PAIR_COLON EOL*
listKeywordPair ::=  keywordKeyColonEOL keywordValue
                     {
                       implements = "org.elixir_lang.psi.KeywordPair"
                       methods = [
                         getKeywordKey
                         getKeywordValue
                         quote
                       ]
                     }
keywordValue ::= containerExpression
                 { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
list ::= OPENING_BRACKET EOL* (listKeywordPair (infixComma listKeywordPair)* COMMA?)? CLOSING_BRACKET
         { implements = "org.elixir_lang.psi.KeywordList" methods = [getKeywordPairList quote] }

/* elixir_tokenizer.erl converts CHAR_TOKEN_TOKENs to their number representation, so `number` in elixir_parser.yrl matches
   Elixir.flex's CHAR_TOKEN_TOKEN and all the different base number rules. */
private numeric ::= charToken |
                    binaryWholeNumber |
                    // decimalFloat starts with decimalWholeNumber, so decimalFloat needs to be first
                    decimalFloat |
                    decimalWholeNumber |
                    hexadecimalWholeNumber |
                    octalWholeNumber |
                    unknownBaseWholeNumber

private quote ::= (charListLine | stringLine)
