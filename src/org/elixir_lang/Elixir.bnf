{
  parserClass="org.elixir_lang.parser.ElixirParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  /*
   * Ordered by rule being extended (extends(regex)=<rule-begin-extended)
   */

  extends("decimal(Float|WholeNUmber)")=decimalNumber
  extends("(.*Whole|decimal)Number")=number

  psiClassPrefix="Elixir"
  psiImplClassSuffix="Impl"
  psiPackage="org.elixir_lang.psi"
  psiImplPackage="org.elixir_lang.psi.impl"
  psiImplUtilClass="org.elixir_lang.psi.impl.ElixirPsiImplUtil"

  elementTypeHolderClass="org.elixir_lang.psi.ElixirTypes"
  elementTypeClass="org.elixir_lang.psi.ElixirElementType"
  tokenTypeClass="org.elixir_lang.psi.ElixirTokenType"

  tokens = [
    BASE_WHOLE_NUMBER_PREFIX = "0"
    BINARY_WHOLE_NUMBER_BASE = "b"
    CALL = ""
    CLOSING_BRACKET = "]"
    // TODO remove once CLOSING_PARENTHESIS is used in emptyParentheses rule
    CLOSING_PARENTHESIS = ")"
    COMMA = ","
    COMMENT = "regexp:#[^\r\n]*(\n|\r|\r\n)?"
    DECIMAL_MARK = "."
    DECIMAL_SEPARATOR = "_"
    DOT_OPERATOR = "."
    END = "end"
    FALSE = "false"
    FN = "fn"
    HEXADECIMAL_WHOLE_NUMBER_BASE = "x"
    IN_OPERATOR = "in"
    INVALID_BINARY_DIGITS = "regexp:[A-Za-z2-9]+"
    INVALID_UNKNOWN_BASE_DIGITS = "regexp:[A-Za-z0-9]+"
    NIL = "nil"
    OBSOLETE_BINARY_WHOLE_NUMBER_BASE = "B"
    OBSOLETE_HEXADECIMAL_WHOLE_NUMBER_BASE = "X"
    OCTAL_WHOLE_NUMBER_BASE = "o"
    OPENING_BRACKET = "["
    // TODO remove once OPENING_PARENTHESIS is used in emptyParentheses rule
    OPENING_PARENTHESIS = "("
    // TOO remove once SEMICOLON is used in endOfExpression rule
    SEMICOLON = ";"
    // TODO remove once containers are available for `{}` after alias for empty structs
    STRUCT_OPERATOR = "%"
    TRUE = "true"
    TYPE_OPERATOR = "::"
    UNKNOWN_WHOLE_NUMBER_BASE = "regexp:A-Zac-z"
    VALID_BINARY_DIGITS = "regexp:[01]+"
    VALID_HEXADECIMAL_DIGITS = "regexp:[A-Fa-f0-9]+"
  ]
}

// expressionList is optional to handle code-less file that contains only EOL between blank lines and order comment
// lines
private elixirFile ::= endOfExpression* (expressionList endOfExpression*)?

/*
 *
 *
 * Expression List
 *
 *
 */

private infixSemicolon ::= EOL* SEMICOLON EOL*
// Must have at least one EOL or SEMICOLON, but at most one SEMICOLON
endOfExpression ::= infixSemicolon | EOL { implements = "org.elixir_lang.psi.Unquoted" }
private expression ::= emptyParentheses |
                       noParenthesesManyArgumentsCall |
                       matchedExpression
private expressionList ::= expression (endOfExpression+ expression | adjacentExpression)*

/*
 *
 *
 * Function Calls
 *
 *
 */


/* The Elixir native lexer converts Strings, CharLists and keywords (false, nil, true) to ALIAS_TOKEN/IDENTIFIER as needed.
   Elixir.flex doesn't do that, so have to list those tokens/rules that would be converted to ALIAS_TOKEN/IDENTIFIER here */
private matchedDotIdentifierOperand ::= IDENTIFIER |
                                        FALSE |
                                        NIL |
                                        TRUE |
                                        binaryString |
                                        listString


/*
 *
 * No Parentheses
 *
 */

/*
 * Many Arguments
 */

private noParenthesesCommaExpression ::= matchedExpression (infixComma noParenthesesExpression)+
/* Have to prevent matchedExpression that is actually a keywordKey from being parsed as just a matchedExpression or
   callArgumentsNoParenthesesCommaExpression COMMA EOL* callArgumentsNoParenthesesKeywords will never match. */
private noParenthesesExpression ::= emptyParentheses |
                                    /* Must be before matchedExpression because noParenthesesExpression is
                                       `matchedExpressionDotIdentifier callArgumentsNoParenthesesManyStrict`
                                       which is longer than `matchedExpressionDotIdentifier` in
                                       matchedExpression. */
                                    /* This will be marked as an error by
                                       {@link org.elixir_lang.inspection.NoParenthesesManyStrict} */
                                    noParenthesesManyStrictNoParenthesesExpression |
                                    matchedExpression !KEYWORD_PAIR_COLON
/* Special class for wrapping noParenthesesCall so that
   {@link: org.elixir_lang.inspection.NoParenthesesManyStrict} can just search for
   ElixirNoParenthesesManyStrictNoParenthesesExpression isn't of having to differentiate between valid and invalid
   ElixirNoParenthesesCall. */
noParenthesesManyStrictNoParenthesesExpression ::= noParenthesesManyArgumentsCall
/* Special class for wrapping rules so that
   {@link: org.elixir_lang.inspection.NoParenthesesStrict} can just search for
   ElixirNoParenthesesStrict instead of having to differentiate between valid and invalid
   rule classes. */
noParenthesesStrict ::= emptyParentheses |
                        OPENING_PARENTHESIS (
                                             noParenthesesKeywords |
                                             noParenthesesManyArguments
                                            ) CLOSING_PARENTHESIS

/* 1. (positional, keywords)
   2. (positional, positional)
   3. (positional, positional, keywords) */
noParenthesesManyArguments ::= matchedExpression infixComma noParenthesesKeywords |
                               noParenthesesCommaExpression (infixComma noParenthesesKeywords)?
private noParenthesesManyArgumentsStrict ::= noParenthesesManyArguments |
                                             noParenthesesStrict

noParenthesesManyArgumentsUnqualifiedCall ::= IDENTIFIER noParenthesesManyArgumentsStrict

private noParenthesesManyArgumentsQualifiedExpression ::= matchedDotExpression noParenthesesManyArgumentsQualifiedCall
left noParenthesesManyArgumentsQualifiedCall ::= infixDotOperator matchedDotIdentifierOperand noParenthesesManyArgumentsStrict

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L124-L125
private noParenthesesManyArgumentsCall ::= noParenthesesManyArgumentsQualifiedExpression | noParenthesesManyArgumentsUnqualifiedCall

/*
 * 1+ Arguments
 */

noParenthesesKeywords ::= noParenthesesKeywordsExpression (infixComma noParenthesesKeywordsExpression)*
noParenthesesKeywordsExpression ::= keywordKeyColonEOL noParenthesesExpression

/*
 * 0 Arguments
 */

left noParenthesesNoArgumentsQualifiedCall ::= infixDotOperator matchedDotIdentifierOperand
noParenthesesNoArgumentsUnqualifiedCallOrVariable ::= IDENTIFIER

/*
 *
 *
 * Heredoc
 *
 *
 */

heredocLinePrefix ::= HEREDOC_LINE_WHITE_SPACE_TOKEN? { methods = [excessWhitespace] }
heredocPrefix ::= HEREDOC_PREFIX_WHITE_SPACE?

/*
 *
 * Quote Heredocs
 *
 */

/*
 * CharList Heredoc
 */

charListHeredoc ::= CHAR_LIST_HEREDOC_PROMOTER EOL
                    interpolatedCharListHeredocLine*
                    heredocPrefix CHAR_LIST_HEREDOC_TERMINATOR
                    {
                      implements = [
                        "org.elixir_lang.psi.Heredoc"
                        "org.elixir_lang.psi.InterpolatedCharList"
                        "org.elixir_lang.psi.InterpolatedCharListHeredocLined"
                        "org.elixir_lang.psi.Quote"
                      ]
                      methods = [
                        addEscapedCharacterCodePoints
                        addFragmentCodePoints
                        addHexadecimalEscapeSequenceCodePoints
                        getFragmentType
                        getHeredocLineList
                        quote
                        quoteBinary
                        quoteEmpty
                        quoteLiteral
                      ]
                      pin = 1
                    }
interpolatedCharListHeredocLine ::= heredocLinePrefix interpolatedCharListBody EOL
                                    {
                                      implements = [
                                        "org.elixir_lang.psi.HeredocLine"
                                      ]
                                      methods = [
                                        getBody
                                        quote
                                      ]
                                    }

/*
 * String Heredoc
 */

stringHeredoc ::= STRING_HEREDOC_PROMOTER EOL
                  interpolatedStringHeredocLine*
                  heredocPrefix STRING_HEREDOC_TERMINATOR
                  {
                    implements = [
                      "org.elixir_lang.psi.Heredoc"
                      "org.elixir_lang.psi.InterpolatedString"
                    ]
                    methods = [
                      addEscapedCharacterCodePoints
                      addFragmentCodePoints
                      addHexadecimalEscapeSequenceCodePoints
                      getFragmentType
                      getHeredocLineList
                      quote
                      quoteBinary
                      quoteEmpty
                      quoteLiteral
                    ]
                    pin = 1
                  }
interpolatedStringHeredocLine ::= heredocLinePrefix interpolatedStringBody EOL
                                  {
                                    implements = [
                                      "org.elixir_lang.psi.HeredocLine"
                                    ]
                                    methods = [
                                      getBody
                                      quote
                                    ]
                                  }

/*
 *
 * Interpolated Sigil Heredocs
 *
 */

sigilModifiers ::= SIGIL_MODIFIER* { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

interpolatedCharListSigilHeredoc ::= TILDE INTERPOLATING_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_HEREDOC_PROMOTER EOL
                                     interpolatedCharListHeredocLine*
                                     heredocPrefix CHAR_LIST_SIGIL_HEREDOC_TERMINATOR sigilModifiers
                                     {
                                       implements = [
                                         "org.elixir_lang.psi.CharListFragmented"
                                         "org.elixir_lang.psi.InterpolatedCharListHeredocLined"
                                         "org.elixir_lang.psi.SigilHeredoc"
                                       ]
                                       methods = [
                                         addEscapedCharacterCodePoints
                                         addFragmentCodePoints
                                         addHexadecimalEscapeSequenceCodePoints
                                         getFragmentType
                                         getHeredocLineList
                                         quote
                                         quoteBinary
                                         quoteEmpty
                                         quoteLiteral
                                         sigilName
                                       ]
                                       pin = 3
                                     }

interpolatedRegexHeredoc ::= TILDE INTERPOLATING_REGEX_SIGIL_NAME REGEX_HEREDOC_PROMOTER EOL
                             interpolatedRegexHeredocLine*
                             heredocPrefix REGEX_HEREDOC_TERMINATOR sigilModifiers
                             {
                               implements = [
                                 "org.elixir_lang.psi.RegexFragmented"
                                 "org.elixir_lang.psi.SigilHeredoc"
                               ]
                               methods = [
                                 addEscapedCharacterCodePoints
                                 addFragmentCodePoints
                                 addHexadecimalEscapeSequenceCodePoints
                                 getFragmentType
                                 getHeredocLineList
                                 quote
                                 quoteBinary
                                 quoteEmpty
                                 quoteLiteral
                                 sigilName
                               ]
                               pin = 3
                             }
interpolatedRegexHeredocLine ::= heredocLinePrefix interpolatedRegexBody EOL
                                 {
                                   implements = [
                                     "org.elixir_lang.psi.HeredocLine"
                                   ]
                                   methods = [
                                     getBody
                                     quote
                                   ]
                                 }
interpolatedRegexBody ::= (interpolation | REGEX_FRAGMENT | escapeSequence)*
                          { implements = "org.elixir_lang.psi.Body" }

interpolatedSigilHeredoc ::= TILDE INTERPOLATING_SIGIL_NAME SIGIL_HEREDOC_PROMOTER EOL
                             interpolatedSigilHeredocLine*
                             heredocPrefix SIGIL_HEREDOC_TERMINATOR sigilModifiers
                             {
                               implements = [
                                 "org.elixir_lang.psi.SigilFragmented"
                                 "org.elixir_lang.psi.SigilHeredoc"
                               ]
                               methods = [
                                 addEscapedCharacterCodePoints
                                 addFragmentCodePoints
                                 addHexadecimalEscapeSequenceCodePoints
                                 getFragmentType
                                 getHeredocLineList
                                 quote
                                 quoteBinary
                                 quoteEmpty
                                 quoteLiteral
                                 sigilName
                               ]
                               pin = 3
                             }
interpolatedSigilHeredocLine ::= heredocLinePrefix interpolatedSigilBody EOL
                                 {
                                   implements = [
                                     "org.elixir_lang.psi.HeredocLine"
                                   ]
                                   methods = [
                                     getBody
                                     quote
                                   ]
                                 }
interpolatedSigilBody ::= (interpolation | SIGIL_FRAGMENT | escapeSequence)*
                          { implements = "org.elixir_lang.psi.Body" }

interpolatedStringSigilHeredoc ::= TILDE INTERPOLATING_STRING_SIGIL_NAME STRING_SIGIL_HEREDOC_PROMOTER EOL
                                     interpolatedStringHeredocLine*
                                     heredocPrefix STRING_SIGIL_HEREDOC_TERMINATOR sigilModifiers
                                     {
                                       implements = [
                                         "org.elixir_lang.psi.StringFragmented"
                                         "org.elixir_lang.psi.InterpolatedStringHeredocLined"
                                         "org.elixir_lang.psi.SigilHeredoc"
                                       ]
                                       methods = [
                                         addEscapedCharacterCodePoints
                                         addFragmentCodePoints
                                         addHexadecimalEscapeSequenceCodePoints
                                         getFragmentType
                                         getHeredocLineList
                                         quote
                                         quoteBinary
                                         quoteEmpty
                                         quoteLiteral
                                         sigilName
                                       ]
                                       pin = 3
                                     }

interpolatedWordsHeredoc ::= TILDE INTERPOLATING_WORDS_SIGIL_NAME WORDS_HEREDOC_PROMOTER EOL
                             interpolatedWordsHeredocLine*
                             heredocPrefix WORDS_HEREDOC_TERMINATOR sigilModifiers
                             {
                               implements = [
                                 "org.elixir_lang.psi.WordsFragmented"
                                 "org.elixir_lang.psi.SigilHeredoc"
                               ]
                               methods = [
                                 addEscapedCharacterCodePoints
                                 addFragmentCodePoints
                                 addHexadecimalEscapeSequenceCodePoints
                                 getFragmentType
                                 getHeredocLineList
                                 quote
                                 quoteBinary
                                 quoteEmpty
                                 quoteLiteral
                                 sigilName
                               ]
                               pin = 3
                             }
interpolatedWordsHeredocLine ::= heredocLinePrefix interpolatedWordsBody EOL
                                 {
                                   implements = [
                                     "org.elixir_lang.psi.HeredocLine"
                                   ]
                                   methods = [
                                     getBody
                                     quote
                                   ]
                                 }
interpolatedWordsBody ::= (interpolation | WORDS_FRAGMENT | escapeSequence)*
                          { implements = "org.elixir_lang.psi.Body" }

/*
 * Literal Sigil Heredocs
 */

literalCharListSigilHeredoc ::= TILDE LITERAL_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_HEREDOC_PROMOTER EOL
                                literalCharListHeredocLine*
                                heredocPrefix CHAR_LIST_SIGIL_HEREDOC_TERMINATOR sigilModifiers
                                {
                                  implements = [
                                    "org.elixir_lang.psi.CharListFragmented"
                                    "org.elixir_lang.psi.SigilHeredoc"
                                  ]
                                  methods = [
                                    addEscapedCharacterCodePoints
                                    addFragmentCodePoints
                                    addHexadecimalEscapeSequenceCodePoints
                                    getFragmentType
                                    getHeredocLineList
                                    quote
                                    quoteBinary
                                    quoteEmpty
                                    quoteLiteral
                                    sigilName
                                  ]
                                  pin = 3
                                }
literalCharListHeredocLine ::= heredocLinePrefix literalCharListBody EOL
                               {
                                 implements = [
                                   "org.elixir_lang.psi.HeredocLine"
                                 ]
                                 methods = [
                                   getBody
                                   quote
                                 ]
                               }
literalCharListBody ::= CHAR_LIST_FRAGMENT*
                        { implements = "org.elixir_lang.psi.Body" }

literalRegexHeredoc ::= TILDE LITERAL_REGEX_SIGIL_NAME REGEX_HEREDOC_PROMOTER EOL
                        literalRegexHeredocLine*
                        heredocPrefix REGEX_HEREDOC_TERMINATOR sigilModifiers
                        {
                          implements = [
                            "org.elixir_lang.psi.RegexFragmented"
                            "org.elixir_lang.psi.SigilHeredoc"
                          ]
                          methods = [
                            addEscapedCharacterCodePoints
                            addFragmentCodePoints
                            addHexadecimalEscapeSequenceCodePoints
                            getFragmentType
                            getHeredocLineList
                            quote
                            quoteBinary
                            quoteEmpty
                            quoteLiteral
                            sigilName
                          ]
                          pin = 3
                        }
literalRegexHeredocLine ::= heredocLinePrefix literalRegexBody EOL
                            {
                              implements = [
                                "org.elixir_lang.psi.HeredocLine"
                              ]
                              methods = [
                                getBody
                                quote
                              ]
                            }
literalRegexBody ::= REGEX_FRAGMENT*
                     { implements = "org.elixir_lang.psi.Body" }

literalSigilHeredoc ::= TILDE LITERAL_SIGIL_NAME SIGIL_HEREDOC_PROMOTER EOL
                        literalSigilHeredocLine*
                        heredocPrefix SIGIL_HEREDOC_TERMINATOR sigilModifiers
                        {
                          implements = [
                            "org.elixir_lang.psi.SigilFragmented"
                            "org.elixir_lang.psi.SigilHeredoc"
                          ]
                          methods = [
                            addEscapedCharacterCodePoints
                            addFragmentCodePoints
                            addHexadecimalEscapeSequenceCodePoints
                            getFragmentType
                            getHeredocLineList
                            quote
                            quoteBinary
                            quoteEmpty
                            quoteLiteral
                            sigilName
                          ]
                          pin = 3
                        }
literalSigilHeredocLine ::= heredocLinePrefix literalSigilBody EOL
                            {
                              implements = [
                                "org.elixir_lang.psi.HeredocLine"
                              ]
                              methods = [
                                getBody
                                quote
                              ]
                            }
literalSigilBody ::= SIGIL_FRAGMENT*
                     { implements = "org.elixir_lang.psi.Body" }
                     
literalStringSigilHeredoc ::= TILDE LITERAL_STRING_SIGIL_NAME STRING_SIGIL_HEREDOC_PROMOTER EOL
                              literalStringHeredocLine*
                              heredocPrefix STRING_SIGIL_HEREDOC_TERMINATOR sigilModifiers
                              {
                                implements = [
                                  "org.elixir_lang.psi.StringFragmented"
                                  "org.elixir_lang.psi.SigilHeredoc"
                                ]
                                methods = [
                                  addEscapedCharacterCodePoints
                                  addFragmentCodePoints
                                  addHexadecimalEscapeSequenceCodePoints
                                  getFragmentType
                                  getHeredocLineList
                                  quote
                                  quoteBinary
                                  quoteEmpty
                                  quoteLiteral
                                  sigilName
                                ]
                                pin = 3
                              }
literalStringHeredocLine ::= heredocLinePrefix literalStringBody EOL
                             {
                               implements = [
                                 "org.elixir_lang.psi.HeredocLine"
                               ]
                               methods = [
                                 getBody
                                 quote
                               ]
                             }
literalStringBody ::= STRING_FRAGMENT*
                      { implements = "org.elixir_lang.psi.Body" }
                      
literalWordsHeredoc ::= TILDE LITERAL_WORDS_SIGIL_NAME WORDS_HEREDOC_PROMOTER EOL
                        literalWordsHeredocLine*
                        heredocPrefix WORDS_HEREDOC_TERMINATOR sigilModifiers
                        {
                          implements = [
                            "org.elixir_lang.psi.WordsFragmented"
                            "org.elixir_lang.psi.SigilHeredoc"
                          ]
                          methods = [
                            addEscapedCharacterCodePoints
                            addFragmentCodePoints
                            addHexadecimalEscapeSequenceCodePoints
                            getFragmentType
                            getHeredocLineList
                            quote
                            quoteBinary
                            quoteEmpty
                            quoteLiteral
                            sigilName
                          ]
                          pin = 3
                        }
literalWordsHeredocLine ::= heredocLinePrefix literalWordsBody EOL
                            {
                              implements = [
                                "org.elixir_lang.psi.HeredocLine"
                              ]
                              methods = [
                                getBody
                                quote
                              ]
                            }
literalWordsBody ::= WORDS_FRAGMENT*
                     { implements = "org.elixir_lang.psi.Body" }

/*
 *
 *
 * Lines (as opposed to Heredocs)
 *
 *
 */

/*
 *
 * Quote Lines
 *
 */


interpolatedCharListBody ::= (interpolation | CHAR_LIST_FRAGMENT | escapeSequence)*
                             { implements =  "org.elixir_lang.psi.Body" }
charListLine ::= CHAR_LIST_PROMOTER interpolatedCharListBody CHAR_LIST_TERMINATOR
                 {
                   implements = [
                     "org.elixir_lang.psi.Atomable"
                     "org.elixir_lang.psi.InterpolatedCharList"
                     "org.elixir_lang.psi.Quotable"
                   ]
                   methods = [
                     addEscapedCharacterCodePoints
                     addFragmentCodePoints
                     addHexadecimalEscapeSequenceCodePoints
                     getFragmentType
                     quote
                     quoteAsAtom
                     quoteBinary
                     quoteEmpty
                     quoteLiteral
                   ]
                 }

interpolatedStringBody ::=  (interpolation | STRING_FRAGMENT | escapeSequence)*
                            { implements = "org.elixir_lang.psi.Body" }
stringLine ::= STRING_PROMOTER
               interpolatedStringBody
               STRING_TERMINATOR
               {
                 implements = [
                   "org.elixir_lang.psi.Atomable"
                   "org.elixir_lang.psi.InterpolatedString"
                   "org.elixir_lang.psi.Quotable"
                 ]
                 methods = [
                   addEscapedCharacterCodePoints
                   addFragmentCodePoints
                   addHexadecimalEscapeSequenceCodePoints
                   getFragmentType
                   quote
                   quoteAsAtom
                   quoteBinary
                   quoteEmpty
                   quoteLiteral
                 ]
               }

/*
 *
 * Sigil Lines
 *
 */

/*
 * Interpolated Sigil Lines
 */

interpolatedCharListSigilLine ::= TILDE INTERPOLATING_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_PROMOTER interpolatedCharListBody CHAR_LIST_SIGIL_TERMINATOR sigilModifiers
                                  {
                                    implements = [
                                      "org.elixir_lang.psi.CharListFragmented"
                                      "org.elixir_lang.psi.SigilLine"
                                    ]
                                    methods = [
                                      addEscapedCharacterCodePoints
                                      addFragmentCodePoints
                                      addHexadecimalEscapeSequenceCodePoints
                                      getBody
                                      getFragmentType
                                      quote
                                      quoteBinary
                                      quoteEmpty
                                      quoteLiteral
                                      sigilName
                                    ]
                                  }

interpolatedRegexLine ::= TILDE INTERPOLATING_REGEX_SIGIL_NAME REGEX_PROMOTER interpolatedRegexBody REGEX_TERMINATOR sigilModifiers
                          {
                            implements = [
                              "org.elixir_lang.psi.RegexFragmented"
                              "org.elixir_lang.psi.SigilLine"
                            ]
                            methods = [
                              addEscapedCharacterCodePoints
                              addFragmentCodePoints
                              addHexadecimalEscapeSequenceCodePoints
                              getBody
                              getFragmentType
                              quote
                              quoteBinary
                              quoteEmpty
                              quoteLiteral
                              sigilName
                            ]
                          }

interpolatedSigilLine ::= TILDE INTERPOLATING_SIGIL_NAME SIGIL_PROMOTER interpolatedSigilBody SIGIL_TERMINATOR sigilModifiers
                          {
                            implements = [
                              "org.elixir_lang.psi.SigilFragmented"
                              "org.elixir_lang.psi.SigilLine"
                            ]
                            methods = [
                              addEscapedCharacterCodePoints
                              addFragmentCodePoints
                              addHexadecimalEscapeSequenceCodePoints
                              getBody
                              getFragmentType
                              quote
                              quoteBinary
                              quoteEmpty
                              quoteLiteral
                              sigilName
                            ]
                          }

interpolatedStringSigilLine ::= TILDE INTERPOLATING_STRING_SIGIL_NAME STRING_SIGIL_PROMOTER interpolatedStringBody STRING_SIGIL_TERMINATOR sigilModifiers
                                {
                                  implements = [
                                    "org.elixir_lang.psi.StringFragmented"
                                    "org.elixir_lang.psi.SigilLine"
                                  ]
                                  methods = [
                                    addEscapedCharacterCodePoints
                                    addFragmentCodePoints
                                    addHexadecimalEscapeSequenceCodePoints
                                    getBody
                                    getFragmentType
                                    quote
                                    quoteBinary
                                    quoteEmpty
                                    quoteLiteral
                                    sigilName
                                  ]
                                }

interpolatedWordsLine ::= TILDE INTERPOLATING_WORDS_SIGIL_NAME WORDS_PROMOTER interpolatedWordsBody WORDS_TERMINATOR sigilModifiers
                          {
                            implements = [
                              "org.elixir_lang.psi.WordsFragmented"
                              "org.elixir_lang.psi.SigilLine"
                            ]
                            methods = [
                              addEscapedCharacterCodePoints
                              addFragmentCodePoints
                              addHexadecimalEscapeSequenceCodePoints
                              getBody
                              getFragmentType
                              quote
                              quoteBinary
                              quoteEmpty
                              quoteLiteral
                              sigilName
                            ]
                          }
/*
 * Literal Sigils
 */

literalCharListSigilLine ::= TILDE LITERAL_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_PROMOTER literalCharListBody CHAR_LIST_SIGIL_TERMINATOR sigilModifiers
                             {
                               implements = [
                                 "org.elixir_lang.psi.CharListFragmented"
                                 "org.elixir_lang.psi.SigilLine"
                               ]
                               methods = [
                                 addEscapedCharacterCodePoints
                                 addFragmentCodePoints
                                 addHexadecimalEscapeSequenceCodePoints
                                 getBody
                                 getFragmentType
                                 quote
                                 quoteBinary
                                 quoteEmpty
                                 quoteLiteral
                                 sigilName
                               ]
                             }

literalRegexLine ::= TILDE LITERAL_REGEX_SIGIL_NAME REGEX_PROMOTER literalRegexBody REGEX_TERMINATOR sigilModifiers
                     {
                       implements = [
                         "org.elixir_lang.psi.RegexFragmented"
                         "org.elixir_lang.psi.SigilLine"
                       ]
                       methods = [
                         addEscapedCharacterCodePoints
                         addFragmentCodePoints
                         addHexadecimalEscapeSequenceCodePoints
                         getBody
                         getFragmentType
                         quote
                         quoteBinary
                         quoteEmpty
                         quoteLiteral
                         sigilName
                       ]
                     }

literalSigilLine ::= TILDE LITERAL_SIGIL_NAME SIGIL_PROMOTER literalSigilBody SIGIL_TERMINATOR sigilModifiers
                     {
                       implements = [
                         "org.elixir_lang.psi.SigilFragmented"
                         "org.elixir_lang.psi.SigilLine"
                       ]
                       methods = [
                         addEscapedCharacterCodePoints
                         addFragmentCodePoints
                         addHexadecimalEscapeSequenceCodePoints
                         getBody
                         getFragmentType
                         quote
                         quoteBinary
                         quoteEmpty
                         quoteLiteral
                         sigilName
                       ]
                     }

literalStringSigilLine ::= TILDE LITERAL_STRING_SIGIL_NAME STRING_SIGIL_PROMOTER literalStringBody STRING_SIGIL_TERMINATOR sigilModifiers
                           {
                             implements = [
                               "org.elixir_lang.psi.StringFragmented"
                               "org.elixir_lang.psi.SigilLine"
                             ]
                             methods = [
                               addEscapedCharacterCodePoints
                               addFragmentCodePoints
                               addHexadecimalEscapeSequenceCodePoints
                               getBody
                               getFragmentType
                               quote
                               quoteBinary
                               quoteEmpty
                               quoteLiteral
                               sigilName
                             ]
                           }

literalWordsLine ::=  TILDE LITERAL_WORDS_SIGIL_NAME WORDS_PROMOTER literalWordsBody WORDS_TERMINATOR sigilModifiers
                      {
                        implements = [
                          "org.elixir_lang.psi.WordsFragmented"
                          "org.elixir_lang.psi.SigilLine"
                        ]
                        methods = [
                          addEscapedCharacterCodePoints
                          addFragmentCodePoints
                          addHexadecimalEscapeSequenceCodePoints
                          getBody
                          getFragmentType
                          quote
                          quoteBinary
                          quoteEmpty
                          quoteLiteral
                          sigilName
                        ]
                      }

/*
 *
 *
 * Matched Expressions - ordered by outer-most (lowest precedence) to inner-most (highest precedence)
 *
 *
 */

private matchedExpression ::= matchedNonNumericCaptureExpression

// non-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L50)
capturePrefixOperator ::= CAPTURE_OPERATOR EOL* { name = "&" }
private nonNumericCapturePrefixOperator ::= capturePrefixOperator !numeric
private matchedNonNumericCaptureExpression ::= matchedNonNumericCaptureOperation | matchedNonNumericCaptureOperand
private matchedNonNumericCaptureOperand ::= matchedNonNumericCaptureOperation | matchedMultiplicationExpression
matchedNonNumericCaptureOperation ::= nonNumericCapturePrefixOperator (noParenthesesManyArgumentsCall | matchedNonNumericCaptureOperand)

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L65)
multiplicationInfixOperator ::= EOL* MULTIPLICATION_OPERATOR EOL* { name = "*, /" }
private matchedMultiplicationExpression ::= matchedMultiplicationLeftOperand matchedMultiplicationOperation*
private matchedMultiplicationLeftOperand ::= matchedNonNumericCaptureOperation | matchedHatExpression
private matchedMultiplicationRightOperand ::= noParenthesesManyArgumentsCall | matchedMultiplicationLeftOperand
left matchedMultiplicationOperation ::= multiplicationInfixOperator matchedMultiplicationRightOperand

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L66)
hatInfixOperator ::= EOL* HAT_OPERATOR EOL* { name = "^^^" }
private matchedHatExpression ::= matchedHatLeftOperand matchedHatOperation*
private matchedHatLeftOperand ::= matchedNonNumericCaptureOperation | matchedUnaryExpression
private matchedHatRightOperand ::= noParenthesesManyArgumentsCall | matchedHatLeftOperand
left matchedHatOperation ::= hatInfixOperator matchedHatRightOperand

// non-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L67)
unaryPrefixOperator ::= (DUAL_OPERATOR | UNARY_OPERATOR) EOL* { name = "+, -, !, ^, not, ~~~" }
private matchedUnaryExpression ::= matchedUnaryOperation | matchedUnaryOperand
private matchedUnaryOperand ::= matchedNonNumericCaptureOperation | matchedUnaryOperation | matchedDotExpression
matchedUnaryOperation ::= unaryPrefixOperator (noParenthesesManyArgumentsCall | matchedUnaryOperand)

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L69)
infixDotOperator ::= EOL* DOT_OPERATOR EOL* { name = "." }
private matchedDotExpression ::= matchedDotLeftOperand (matchedDotOperation* matchedDotRightMostOperation)?
private matchedDotLeftOperand ::= matchedAtExpression
private matchedDotRightOperand ::= (
                                    ALIAS_TOKEN |
                                    IDENTIFIER |
                                    FALSE |
                                    NIL |
                                    TRUE |
                                    binaryString |
                                    listString
                                   ) &infixDotOperator
left matchedDotOperation ::= infixDotOperator matchedDotRightOperand
private matchedDotRightMostOperation ::= noParenthesesNoArgumentsQualifiedCall | qualifiedAlias
left qualifiedAlias ::= infixDotOperator ALIAS_TOKEN

// non-associative (https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L70)
atPrefixOperator ::= AT_OPERATOR EOL* { name = "@" }
private matchedAtExpression ::= matchedAtOperation | matchedAtOperand
private matchedAtOperand ::= matchedNonNumericCaptureOperation | matchedUnaryOperation | noParenthesesNoArgumentsUnqualifiedCallOrVariable | accessExpression
matchedAtOperation ::= atPrefixOperator (noParenthesesManyArgumentsCall | matchedAtOperand)

private accessExpression ::= atCharTokenOrNumberOperation |
                             captureCharTokenOrNumberOperation |
                             unaryCharTokenOrNumberOperation |
                             OPENING_PARENTHESIS infixSemicolon CLOSING_PARENTHESIS |
                             numeric |
                             list |
                             binaryString |
                             listString |
                             sigil |
                             atomKeyword |
                             atom |
                             alias

// keywords that map to atoms
atomKeyword ::= FALSE | NIL | TRUE
                { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

alias ::= ALIAS_TOKEN
          { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

/*
 *
 *
 * Whole Numbers
 *
 *
 *
 */

decimalDigits ::= INVALID_DECIMAL_DIGITS | VALID_DECIMAL_DIGITS
                  { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
decimalWholeNumber ::= decimalDigits (DECIMAL_SEPARATOR? decimalDigits)*
                        {
                          implements = "org.elixir_lang.psi.WholeNumber"
                          methods = [
                            base
                            digitsList
                            quote
                          ]
                        }

/*
 *
 * Base (Non-Decimal) Whole Numbers
 *
 */

/*
 * Binary (2)
 */

binaryDigits ::= INVALID_BINARY_DIGITS | VALID_BINARY_DIGITS
                 { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
binaryWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX (BINARY_WHOLE_NUMBER_BASE | OBSOLETE_BINARY_WHOLE_NUMBER_BASE) binaryDigits+
                     {
                       implements = "org.elixir_lang.psi.WholeNumber"
                       methods = [
                         base
                         digitsList
                         quote
                       ]
                       pin = 2
                     }

/*
 * Hexadecimal (16)
 */

hexadecimalDigits ::= INVALID_HEXADECIMAL_DIGITS | VALID_HEXADECIMAL_DIGITS
                      { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
hexadecimalWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX (HEXADECIMAL_WHOLE_NUMBER_BASE | OBSOLETE_HEXADECIMAL_WHOLE_NUMBER_BASE) hexadecimalDigits+
                           {
                             implements = "org.elixir_lang.psi.WholeNumber"
                             methods = [
                               base
                               digitsList
                               quote
                             ]
                             pin = 2
                           }

/*
 * Octal (8)
 */

octalDigits ::= INVALID_OCTAL_DIGITS | VALID_OCTAL_DIGITS
                { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
octalWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX OCTAL_WHOLE_NUMBER_BASE octalDigits+
                     {
                       implements = "org.elixir_lang.psi.WholeNumber"
                       methods = [
                         base
                         digitsList
                         quote
                       ]
                       pin = 2
                     }

/*
 * Unknown (1-36)
 */

unknownBaseDigits ::= INVALID_UNKNOWN_BASE_DIGITS
                      { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
unknownBaseWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX UNKNOWN_WHOLE_NUMBER_BASE unknownBaseDigits+
                           {
                             implements = "org.elixir_lang.psi.WholeNumber"
                             methods = [
                               base
                               digitsList
                               quote
                             ]
                             pin=2
                           }

/*
 *
 *
 * In alphabetical order
 *
 *
 */

// an expression in an expressionList that is NOT preceded by endOfExpression(s)
adjacentExpression ::= expression
atom ::= COLON (ATOM_FRAGMENT | quote)
         { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

private binaryString ::= stringLine | stringHeredoc
private infixComma ::= COMMA EOL*

private containerExpression ::= emptyParentheses

decimalFloat ::= decimalFloatIntegral DECIMAL_MARK decimalFloatFractional (EXPONENT_MARK decimalFloatExponent)?
                 { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
decimalFloatExponent ::= decimalFloatExponentSign decimalWholeNumber
decimalFloatExponentSign ::= DUAL_OPERATOR?
decimalFloatFractional ::= decimalWholeNumber
decimalFloatIntegral ::= decimalWholeNumber

// decimalFloat starts with decimalWholeNumber, so decimalFloat needs to be first
decimalNumber ::= decimalFloat |
                  decimalWholeNumber
private escapeSequence ::= hexadecimalEscapeSequence |
                           escapedEOL |
                           /* Must be last so that ESCAPE ('\') can be pinned in escapedCharacter without excluding
                              ("\x") in hexadecimalEscapeSequence  */
                           escapedCharacter
hexadecimalEscapeSequence ::= ESCAPE HEXADECIMAL_WHOLE_NUMBER_BASE (openHexadecimalEscapeSequence | enclosedHexadecimalEscapeSequence) { methods = [codePoint] pin = 2 }
enclosedHexadecimalEscapeSequence ::= OPENING_CURLY VALID_HEXADECIMAL_DIGITS CLOSING_CURLY
                                      { implements = "org.elixir_lang.psi.EscapedHexadecimalDigits" methods = [codePoint] pin = 1 }
openHexadecimalEscapeSequence ::= VALID_HEXADECIMAL_DIGITS
                                  { implements = "org.elixir_lang.psi.EscapedHexadecimalDigits" methods = [codePoint] }
escapedCharacter ::= ESCAPE ESCAPED_CHARACTER_TOKEN
                     { implements = "org.elixir_lang.psi.EscapeSequence" methods = [codePoint] pin = 1 }
escapedEOL ::= ESCAPE EOL
emptyParentheses ::= OPENING_PARENTHESIS EOL* CLOSING_PARENTHESIS
                     { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
interpolation ::= INTERPOLATION_START elixirFile INTERPOLATION_END
                  { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
keywordKey ::= ALIAS_TOKEN |
               AND_OPERATOR |
               ARROW_OPERATOR |
               ASSOCIATION_OPERATOR |
               AT_OPERATOR |
               BIT_STRING_OPERATOR |
               CAPTURE_OPERATOR |
               COMPARISON_OPERATOR |
               DUAL_OPERATOR |
               HAT_OPERATOR |
               IDENTIFIER |
               IN_MATCH_OPERATOR |
               IN_OPERATOR |
               MAP_OPERATOR |
               MATCH_OPERATOR |
               MULTIPLICATION_OPERATOR |
               OR_OPERATOR |
               PIPE_OPERATOR |
               RELATIONAL_OPERATOR |
               STAB_OPERATOR |
               STRUCT_OPERATOR |
               TUPLE_OPERATOR |
               TWO_OPERATOR |
               UNARY_OPERATOR |
               WHEN_OPERATOR |
               quote
               { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
private keywordKeyColonEOL ::= keywordKey KEYWORD_PAIR_COLON EOL*
keywordPair ::=  keywordKeyColonEOL keywordValue
                 { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
keywordValue ::= containerExpression
                 { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
list ::= OPENING_BRACKET EOL* (keywordPair (infixComma keywordPair)* COMMA?)? CLOSING_BRACKET
         { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
private listString ::= charListLine | charListHeredoc


atCharTokenOrNumberOperation ::= atPrefixOperator numeric
captureCharTokenOrNumberOperation ::= capturePrefixOperator numeric
unaryCharTokenOrNumberOperation ::= unaryPrefixOperator numeric

/* elixir_tokenizer.erl converts CHAR_TOKENs to their number representation, so `number` in elixir_parser.yrl matches
   Elixir.flex's NUMBER and CHAR_TOKEN. */
private numeric ::= CHAR_TOKEN | number

//noParenthesesOneExpression ::= dotIdentifier

number ::= binaryWholeNumber |
           decimalNumber |
           hexadecimalWholeNumber |
           octalWholeNumber |
           unknownBaseWholeNumber
/*
 * Number Operations - Used in accessExpression
 */

private quote ::= (charListLine | stringLine)
private sigil ::= interpolatedCharListSigilLine |
                  interpolatedCharListSigilHeredoc |
                  interpolatedRegexHeredoc |
                  interpolatedSigilHeredoc |
                  interpolatedStringSigilHeredoc |
                  interpolatedWordsHeredoc |
                  interpolatedWordsLine |
                  interpolatedRegexLine |
                  interpolatedSigilLine |
                  interpolatedStringSigilLine |
                  literalCharListSigilLine |
                  literalCharListSigilHeredoc |
                  literalRegexHeredoc |
                  literalSigilHeredoc |
                  literalStringSigilHeredoc |
                  literalWordsHeredoc |
                  literalRegexLine |
                  literalSigilLine |
                  literalStringSigilLine |
                  literalWordsLine
