{
  parserClass="org.elixir_lang.parser.ElixirParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  extends("keywordKey")=atom
  extends("atom|(at|binary|capture|unary)Operation|emptyParentheses|keyword(Pair|Value)|value")=expression
  extends("(addition|and|arrow|association|comparison|dot|hat|in|inMatch|match|multiplication|or|pipe|relational|stab|two|type|when)Operation")=binaryOperation
  extends("list")=value

  psiClassPrefix="Elixir"
  psiImplClassSuffix="Impl"
  psiPackage="org.elixir_lang.psi"
  psiImplPackage="org.elixir_lang.psi.impl"

  elementTypeHolderClass="org.elixir_lang.psi.ElixirTypes"
  elementTypeClass="org.elixir_lang.psi.ElixirElementType"
  tokenTypeClass="org.elixir_lang.psi.ElixirTokenType"

  tokens = [
    CLOSING_BRACKET = "]"
    // TODO remove once CLOSING_PARENTHESIS is used in emptyParentheses rule
    CLOSING_PARENTHESIS = ")"
    COMMA = ","
    COMMENT = "regexp:#[^\r\n]*(\n|\r|\r\n)?"
    DOT_OPERATOR = "."
    IN_OPERATOR = "in"
    OPENING_BRACKET = "["
    // TODO remove once OPENING_PARENTHESIS is used in emptyParentheses rule
    OPENING_PARENTHESIS = "("
    // TOO remove once SEMICOLON is used in endOfExpression rule
    SEMICOLON = ";"
    // TODO remove once containers are available for `{}` after alias for empty structs
    STRUCT_OPERATOR = "%"
  ]
}

// expressionList is optional to handle code-less file that contains only EOL between blank lines and order comment
// lines
elixirFile ::= endOfExpression* (expressionList endOfExpression*)?

// In alphabetical order

/* Unlike other binary operation, additionOperations cannot begin with EOLs: if there are EOLs, then the +/-
   is interpreted as unaryOperation */
additionOperation ::= expression DUAL_OPERATOR EOL* expression
andOperation ::= expression EOL* AND_OPERATOR EOL* expression
arrowOperation ::= expression EOL* ARROW_OPERATOR EOL* expression
associationOperation ::= expression EOL* ASSOCIATION_OPERATOR EOL* expression { rightAssociative = true }
atom ::= COLON (ATOM_FRAGMENT | quote)
atOperation ::= AT_OPERATOR EOL* expression
fake binaryOperation ::= expression + {
  methods = [
    left = "/expr[0]"  // will be @NotNull as far as we have "+" in the expression
    right = "/expr[1]" // "expr" is the name of the auto-calculated child property (singular or list)
  ]
}
captureOperation ::= CAPTURE_OPERATOR EOL* expression
charList ::= CHAR_LIST_PROMOTER
             interpolatedCharListBody
             CHAR_LIST_TERMINATOR
charListHeredoc ::= CHAR_LIST_HEREDOC_PROMOTER EOL
                    interpolatedCharListBody
                    CHAR_LIST_HEREDOC_TERMINATOR
comparisonOperation ::= expression EOL* COMPARISON_OPERATOR EOL* expression
private containerExpression ::= emptyParentheses
dotOperation ::= expression EOL* DOT_OPERATOR EOL* expression
emptyParentheses ::= OPENING_PARENTHESIS EOL* CLOSING_PARENTHESIS
// Must have at least one EOL or SEMICOLON, but at most one SEMICOLON
endOfExpression ::= EOL* SEMICOLON EOL* | EOL
/* order of choices is lower precedence first as lower precedence operation are meant to enclose higher precedence
   operators.
   @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L44-L71 */
expression ::= stabOperation |
               captureOperation |
               inMatchOperation |
               whenOperation |
               typeOperation |
               pipeOperation |
               associationOperation |
               matchOperation |
               orOperation |
               andOperation |
               comparisonOperation |
               relationalOperation |
               arrowOperation |
               inOperation |
               twoOperation |
               additionOperation |
               multiplicationOperation |
               hatOperation |
               unaryOperation |
               dotOperation |
               atOperation |
               value |
               emptyParentheses
private expressionList ::= expression (endOfExpression+ expression)*
hatOperation ::= expression EOL* HAT_OPERATOR EOL* expression
inMatchOperation ::= expression EOL* IN_MATCH_OPERATOR EOL* expression
inOperation ::= expression EOL* IN_OPERATOR EOL* expression
private interpolatedCharListSigil ::= TILDE INTERPOLATING_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_PROMOTER interpolatedCharListBody CHAR_LIST_SIGIL_TERMINATOR
private interpolatedCharListBody ::= (interpolation | CHAR_LIST_FRAGMENT | VALID_ESCAPE_SEQUENCE)*
private interpolatedHeredocCharListSigil ::= TILDE INTERPOLATING_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_HEREDOC_PROMOTER EOL
                                             interpolatedCharListBody
                                             CHAR_LIST_SIGIL_HEREDOC_TERMINATOR
private interpolatedHeredocRegex ::= TILDE INTERPOLATING_REGEX_SIGIL_NAME REGEX_HEREDOC_PROMOTER EOL
                                     interpolatedRegexBody
                                     REGEX_HEREDOC_TERMINATOR SIGIL_MODIFIER*
private interpolatedHeredocSigil ::= TILDE INTERPOLATING_SIGIL_NAME SIGIL_HEREDOC_PROMOTER EOL
                                     interpolatedSigilBody
                                     SIGIL_HEREDOC_PROMOTER SIGIL_MODIFIER*
private interpolatedHeredocStringSigil ::= TILDE INTERPOLATING_STRING_SIGIL_NAME STRING_SIGIL_HEREDOC_PROMOTER EOL
                                           interpolatedStringBody
                                           STRING_SIGIL_HEREDOC_TERMINATOR
private interpolatedHeredocWords ::= TILDE INTERPOLATING_WORDS_SIGIL_NAME WORDS_HEREDOC_PROMOTER EOL
                                     interpolatedWordsBody
                                     WORDS_HEREDOC_TERMINATOR SIGIL_MODIFIER*
private interpolatedRegex ::= TILDE INTERPOLATING_REGEX_SIGIL_NAME REGEX_PROMOTER interpolatedRegexBody REGEX_TERMINATOR SIGIL_MODIFIER*
private interpolatedRegexBody ::= (interpolation | REGEX_FRAGMENT | VALID_ESCAPE_SEQUENCE)*
private interpolatedSigil ::= TILDE INTERPOLATING_SIGIL_NAME SIGIL_PROMOTER interpolatedSigilBody SIGIL_TERMINATOR SIGIL_MODIFIER*
private interpolatedSigilBody ::= (interpolation | SIGIL_FRAGMENT | VALID_ESCAPE_SEQUENCE)*
private interpolatedStringSigil ::= TILDE INTERPOLATING_STRING_SIGIL_NAME STRING_SIGIL_PROMOTER interpolatedStringBody STRING_SIGIL_TERMINATOR
private interpolatedStringBody ::=  (interpolation | STRING_FRAGMENT | VALID_ESCAPE_SEQUENCE)*
private interpolatedWordsBody ::= (interpolation | WORDS_FRAGMENT | VALID_ESCAPE_SEQUENCE)*
interpolation ::= INTERPOLATION_START expressionList? INTERPOLATION_END
keywordKey ::= (IDENTIFIER | KEYWORD_KEY_LITERAL | quote)
keywordPair ::=  keywordKey COLON EOL* keywordValue
keywordValue ::= containerExpression
list ::= OPENING_BRACKET EOL* (keywordPair (COMMA EOL* keywordPair)* COMMA?)? CLOSING_BRACKET
private literalCharListBody ::= CHAR_LIST_FRAGMENT*
private literalCharListSigil ::= TILDE LITERAL_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_PROMOTER literalCharListBody CHAR_LIST_SIGIL_TERMINATOR
private literalHeredocRegex ::= TILDE LITERAL_REGEX_SIGIL_NAME REGEX_HEREDOC_PROMOTER EOL
                                literalRegexBody
                                REGEX_HEREDOC_TERMINATOR SIGIL_MODIFIER*
private literalHeredocSigil ::= TILDE LITERAL_SIGIL_NAME SIGIL_HEREDOC_PROMOTER EOL
                                literalSigilBody
                                SIGIL_HEREDOC_TERMINATOR SIGIL_MODIFIER*
private literalHeredocStringSigil ::= TILDE LITERAL_STRING_SIGIL_NAME STRING_SIGIL_HEREDOC_PROMOTER EOL
                                      literalStringBody
                                      STRING_SIGIL_HEREDOC_TERMINATOR
private literalHeredocWords ::= TILDE LITERAL_WORDS_SIGIL_NAME WORDS_HEREDOC_PROMOTER EOL
                                literalWordsBody
                                WORDS_HEREDOC_TERMINATOR SIGIL_MODIFIER*
private literalRegex ::= TILDE LITERAL_SIGIL_NAME REGEX_PROMOTER literalRegexBody REGEX_TERMINATOR SIGIL_MODIFIER*
private literalRegexBody ::= REGEX_FRAGMENT*
private literalSigil ::= TILDE LITERAL_SIGIL_NAME SIGIL_PROMOTER literalSigilBody SIGIL_TERMINATOR SIGIL_MODIFIER*
private literalSigilBody ::= SIGIL_FRAGMENT*
private literalStringBody ::= STRING_FRAGMENT*
private literalStringSigil ::= TILDE LITERAL_STRING_SIGIL_NAME STRING_SIGIL_PROMOTER literalStringBody STRING_SIGIL_TERMINATOR
private literalWords ::=  TILDE LITERAL_SIGIL_NAME WORDS_PROMOTER literal WORDS_TERMINATOR SIGIL_MODIFIER*
private literalWordsBody ::= WORDS_FRAGMENT*
matchOperation ::= expression EOL* MATCH_OPERATOR EOL* expression { rightAssociative = true }
multiplicationOperation ::= expression EOL* MULTIPLICATION_OPERATOR EOL* expression
orOperation ::= expression EOL* OR_OPERATOR EOL* expression
pipeOperation ::= expression EOL* PIPE_OPERATOR EOL* expression { rightAssociative = true }
private quote ::= (charList | string)
relationalOperation ::= expression EOL* RELATIONAL_OPERATOR EOL* expression
sigil ::= interpolatedCharListSigil |
          interpolatedHeredocCharListSigil |
          interpolatedHeredocRegex |
          interpolatedHeredocSigil |
          interpolatedHeredocStringSigil |
          interpolatedHeredocWords |
          interpolatedRegex |
          interpolatedSigil |
          interpolatedStringSigil |
          literalCharListSigil |
          literalHeredocRegex |
          literalHeredocSigil |
          literalHeredocStringSigil |
          literalHeredocWords |
          literalRegex |
          literalSigil |
          literalStringSigil |
          literalWords
stabOperation ::= expression EOL* STAB_OPERATOR EOL* expression { rightAssociative = true }
string ::= STRING_PROMOTER
           interpolatedStringBody
           STRING_TERMINATOR
stringHeredoc ::= STRING_HEREDOC_PROMOTER EOL
                  interpolatedStringBody
                  STRING_HEREDOC_TERMINATOR
twoOperation ::= expression EOL* TWO_OPERATOR EOL* expression { rightAssociative = true }
typeOperation ::= expression EOL* TYPE_OPERATOR EOL* expression { rightAssociative = true }
unaryOperation ::= (DUAL_OPERATOR | UNARY_OPERATOR) EOL* expression
value ::= ALIAS | atom | BIT_STRING_OPERATOR | CHAR_TOKEN | list| NUMBER | charListHeredoc | IDENTIFIER | MAP_OPERATOR | quote | sigil | stringHeredoc | TUPLE_OPERATOR
whenOperation ::= expression EOL* WHEN_OPERATOR EOL* expression { rightAssociative = true }
