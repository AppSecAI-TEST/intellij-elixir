{
  parserClass="org.elixir_lang.parser.ElixirParser"

 extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  /*
   * Ordered by rule being extended (extends(regex)=<rule-begin-extended)
   */

  extends("decimal(Float|WholeNUmber)")=decimalNumber
  extends("(.*Whole|decimal)Number")=number

  psiClassPrefix="Elixir"
  psiImplClassSuffix="Impl"
  psiPackage="org.elixir_lang.psi"
  psiImplPackage="org.elixir_lang.psi.impl"

  elementTypeHolderClass="org.elixir_lang.psi.ElixirTypes"
  elementTypeClass="org.elixir_lang.psi.ElixirElementType"
  tokenTypeClass="org.elixir_lang.psi.ElixirTokenType"

  tokens = [
    BASE_WHOLE_NUMBER_PREFIX = "0"
    BINARY_WHOLE_NUMBER_BASE = "b"
    CALL = ""
    CLOSING_BRACKET = "]"
    // TODO remove once CLOSING_PARENTHESIS is used in emptyParentheses rule
    CLOSING_PARENTHESIS = ")"
    COMMA = ","
    COMMENT = "regexp:#[^\r\n]*(\n|\r|\r\n)?"
    DECIMAL_MARK = "."
    DECIMAL_SEPARATOR = "_"
    DOT_OPERATOR = "."
    END = "end"
    FALSE = "false"
    FN = "fn"
    HEXADECIMAL_WHOLE_NUMBER_BASE = "x"
    IN_OPERATOR = "in"
    INVALID_BINARY_DIGITS = "regexp:[A-Za-z2-9]+"
    INVALID_UNKNOWN_BASE_DIGITS = "regexp:[A-Za-z0-9]+"
    NIL = "nil"
    OBSOLETE_BINARY_WHOLE_NUMBER_BASE = "B"
    OBSOLETE_HEXADECIMAL_WHOLE_NUMBER_BASE = "X"
    OCTAL_WHOLE_NUMBER_BASE = "o"
    OPENING_BRACKET = "["
    // TODO remove once OPENING_PARENTHESIS is used in emptyParentheses rule
    OPENING_PARENTHESIS = "("
    // TOO remove once SEMICOLON is used in endOfExpression rule
    SEMICOLON = ";"
    // TODO remove once containers are available for `{}` after alias for empty structs
    STRUCT_OPERATOR = "%"
    TRUE = "true"
    UNKNOWN_WHOLE_NUMBER_BASE = "regexp:A-Zac-z"
    VALID_BINARY_DIGITS = "regexp:[01]+"
    VALID_HEXADECIMAL_DIGITS = "regexp:[A-Fa-f0-9]+"
  ]
}

// expressionList is optional to handle code-less file that contains only EOL between blank lines and order comment
// lines
elixirFile ::= endOfExpression* (expressionList endOfExpression*)?

/*
 * In alphabetical order
 */

// an expression in an expressionList that is NOT preceded by endOfExpression(s)
adjacentExpression ::= expression
atom ::= COLON (ATOM_FRAGMENT | quote) { extends = maxExpression }
binaryWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX (BINARY_WHOLE_NUMBER_BASE | OBSOLETE_BINARY_WHOLE_NUMBER_BASE) (INVALID_BINARY_DIGITS | VALID_BINARY_DIGITS)+ { pin=2 }
private binaryString ::= string | stringHeredoc
private callArgumentsNoParenthesesCommaExpression ::= matchedExpressionRoot (infixComma callArgumentsNoParenthesesExpression)+
private infixComma ::= COMMA EOL*
/* Have to prevent matchedExpression that is actually a keywordKey from being parsed as just a matchedExpression or
   callArgumentsNoParenthesesCommaExpression COMMA EOL* callArgumentsNoParenthesesKeywords will never match. */
private callArgumentsNoParenthesesExpression ::= emptyParentheses |
                                                 /* Must be before matchedExpression because noParenthesesExpression is
                                                    `matchedExpressionDotIdentifier callArgumentsNoParenthesesManyStrict`
                                                    which is longer than `matchedExpressionDotIdentifier` in
                                                    matchedExpression. */
                                                 /* This will be marked as an error by
                                                    {@link org.elixir_lang.inspection.NoParenthesesManyStrict} */
                                                 noParenthesesManyStrictNoParenthesesExpression |
                                                 matchedExpressionRoot !KEYWORD_PAIR_COLON
callArgumentsNoParenthesesKeywords ::= callArgumentsNoParenthesesKeywordsExpression (infixComma callArgumentsNoParenthesesKeywordsExpression)*
callArgumentsNoParenthesesKeywordsExpression ::= keywordKeyColonEOL callArgumentsNoParenthesesExpression
/* 1. (positional, keywords)
   2. (positional, positional)
   3. (positional, positional, keywords) */
callArgumentsNoParenthesesMany ::= matchedExpressionRoot infixComma callArgumentsNoParenthesesKeywords |
                                   callArgumentsNoParenthesesCommaExpression (infixComma callArgumentsNoParenthesesKeywords)?
private callArgumentsNoParenthesesManyStrict ::= callArgumentsNoParenthesesMany |
                                                 noParenthesesStrict
charList ::= CHAR_LIST_PROMOTER
             interpolatedCharListBody
             CHAR_LIST_TERMINATOR
charListHeredoc ::= CHAR_LIST_HEREDOC_PROMOTER EOL
                    interpolatedCharListBody
                    CHAR_LIST_HEREDOC_TERMINATOR
private containerExpression ::= emptyParentheses
decimalFloat ::= decimalWholeNumber DECIMAL_MARK decimalWholeNumber (EXPONENT_MARK DUAL_OPERATOR? decimalWholeNumber)?
decimalWholeNumber ::= {VALID_DECIMAL_DIGITS} ({DECIMAL_SEPARATOR}? (INVALID_DECIMAL_DIGITS | VALID_DECIMAL_DIGITS))*
// decimalFloat starts with decimalWholeNumber, so decimalFloat needs to be first
decimalNumber ::= decimalFloat |
                  decimalWholeNumber
emptyParentheses ::= OPENING_PARENTHESIS EOL* CLOSING_PARENTHESIS
// Must have at least one EOL or SEMICOLON, but at most one SEMICOLON
endOfExpression ::= infixSemicolon | EOL
private infixSemicolon ::= EOL* SEMICOLON EOL*
private expression ::= expressionRoot
private expressionList ::= expression (endOfExpression+ expression | adjacentExpression)*
hexadecimalWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX (HEXADECIMAL_WHOLE_NUMBER_BASE | OBSOLETE_HEXADECIMAL_WHOLE_NUMBER_BASE) (INVALID_HEXADECIMAL_DIGITS | VALID_HEXADECIMAL_DIGITS)+ { pin=2 }
private interpolatedCharListSigil ::= TILDE INTERPOLATING_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_PROMOTER interpolatedCharListBody CHAR_LIST_SIGIL_TERMINATOR
private interpolatedCharListBody ::= (interpolation | CHAR_LIST_FRAGMENT | VALID_ESCAPE_SEQUENCE)*
private interpolatedHeredocCharListSigil ::= TILDE INTERPOLATING_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_HEREDOC_PROMOTER EOL
                                             interpolatedCharListBody
                                             CHAR_LIST_SIGIL_HEREDOC_TERMINATOR
private interpolatedHeredocRegex ::= TILDE INTERPOLATING_REGEX_SIGIL_NAME REGEX_HEREDOC_PROMOTER EOL
                                     interpolatedRegexBody
                                     REGEX_HEREDOC_TERMINATOR SIGIL_MODIFIER*
private interpolatedHeredocSigil ::= TILDE INTERPOLATING_SIGIL_NAME SIGIL_HEREDOC_PROMOTER EOL
                                     interpolatedSigilBody
                                     SIGIL_HEREDOC_PROMOTER SIGIL_MODIFIER*
private interpolatedHeredocStringSigil ::= TILDE INTERPOLATING_STRING_SIGIL_NAME STRING_SIGIL_HEREDOC_PROMOTER EOL
                                           interpolatedStringBody
                                           STRING_SIGIL_HEREDOC_TERMINATOR
private interpolatedHeredocWords ::= TILDE INTERPOLATING_WORDS_SIGIL_NAME WORDS_HEREDOC_PROMOTER EOL
                                     interpolatedWordsBody
                                     WORDS_HEREDOC_TERMINATOR SIGIL_MODIFIER*
private interpolatedRegex ::= TILDE INTERPOLATING_REGEX_SIGIL_NAME REGEX_PROMOTER interpolatedRegexBody REGEX_TERMINATOR SIGIL_MODIFIER*
private interpolatedRegexBody ::= (interpolation | REGEX_FRAGMENT | VALID_ESCAPE_SEQUENCE)*
private interpolatedSigil ::= TILDE INTERPOLATING_SIGIL_NAME SIGIL_PROMOTER interpolatedSigilBody SIGIL_TERMINATOR SIGIL_MODIFIER*
private interpolatedSigilBody ::= (interpolation | SIGIL_FRAGMENT | VALID_ESCAPE_SEQUENCE)*
private interpolatedStringSigil ::= TILDE INTERPOLATING_STRING_SIGIL_NAME STRING_SIGIL_PROMOTER interpolatedStringBody STRING_SIGIL_TERMINATOR
private interpolatedStringBody ::=  (interpolation | STRING_FRAGMENT | VALID_ESCAPE_SEQUENCE)*
private interpolatedWordsBody ::= (interpolation | WORDS_FRAGMENT | VALID_ESCAPE_SEQUENCE)*
interpolation ::= INTERPOLATION_START expressionList? INTERPOLATION_END
keywordKey ::= ALIAS |
               AND_OPERATOR |
               ARROW_OPERATOR |
               ASSOCIATION_OPERATOR |
               AT_OPERATOR |
               BIT_STRING_OPERATOR |
               CAPTURE_OPERATOR |
               COMPARISON_OPERATOR |
               DUAL_OPERATOR |
               HAT_OPERATOR |
               IDENTIFIER |
               IN_MATCH_OPERATOR |
               IN_OPERATOR |
               MAP_OPERATOR |
               MATCH_OPERATOR |
               MULTIPLICATION_OPERATOR |
               OR_OPERATOR |
               PIPE_OPERATOR |
               RELATIONAL_OPERATOR |
               STAB_OPERATOR |
               STRUCT_OPERATOR |
               TUPLE_OPERATOR |
               TWO_OPERATOR |
               UNARY_OPERATOR |
               WHEN_OPERATOR |
               quote
private keywordKeyColonEOL ::= keywordKey KEYWORD_PAIR_COLON EOL*
keywordPair ::=  keywordKeyColonEOL keywordValue
keywordValue ::= containerExpression
list ::= OPENING_BRACKET EOL* (keywordPair (infixComma keywordPair)* COMMA?)? CLOSING_BRACKET
private listString ::= charList | charListHeredoc
private literalCharListBody ::= CHAR_LIST_FRAGMENT*
private literalCharListSigil ::= TILDE LITERAL_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_PROMOTER literalCharListBody CHAR_LIST_SIGIL_TERMINATOR
private literalHeredocRegex ::= TILDE LITERAL_REGEX_SIGIL_NAME REGEX_HEREDOC_PROMOTER EOL
                                literalRegexBody
                                REGEX_HEREDOC_TERMINATOR SIGIL_MODIFIER*
private literalHeredocSigil ::= TILDE LITERAL_SIGIL_NAME SIGIL_HEREDOC_PROMOTER EOL
                                literalSigilBody
                                SIGIL_HEREDOC_TERMINATOR SIGIL_MODIFIER*
private literalHeredocStringSigil ::= TILDE LITERAL_STRING_SIGIL_NAME STRING_SIGIL_HEREDOC_PROMOTER EOL
                                      literalStringBody
                                      STRING_SIGIL_HEREDOC_TERMINATOR
private literalHeredocWords ::= TILDE LITERAL_WORDS_SIGIL_NAME WORDS_HEREDOC_PROMOTER EOL
                                literalWordsBody
                                WORDS_HEREDOC_TERMINATOR SIGIL_MODIFIER*
private literalRegex ::= TILDE LITERAL_SIGIL_NAME REGEX_PROMOTER literalRegexBody REGEX_TERMINATOR SIGIL_MODIFIER*
private literalRegexBody ::= REGEX_FRAGMENT*
private literalSigil ::= TILDE LITERAL_SIGIL_NAME SIGIL_PROMOTER literalSigilBody SIGIL_TERMINATOR SIGIL_MODIFIER*
private literalSigilBody ::= SIGIL_FRAGMENT*
private literalStringBody ::= STRING_FRAGMENT*
private literalStringSigil ::= TILDE LITERAL_STRING_SIGIL_NAME STRING_SIGIL_PROMOTER literalStringBody STRING_SIGIL_TERMINATOR
private literalWords ::=  TILDE LITERAL_SIGIL_NAME WORDS_PROMOTER literal WORDS_TERMINATOR SIGIL_MODIFIER*
private literalWordsBody ::= WORDS_FRAGMENT*

private expressionRoot ::= captureExpressionOperation
private matchedExpressionRoot ::= captureMatchedExpressionOperation

// non-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L50)
capturePrefixOperator ::= CAPTURE_OPERATOR EOL* { name = "&" }
// captureCharTokenOrNumberOperation has higher precedence, so make sure this doesn't match it
private nonNumericCapturePrefixOperator ::= capturePrefixOperator !charTokenOrNumber

private captureExpressionOperand ::= captureExpressionPrefixOperation | matchedExpressionInMatchExpressionOperation
captureExpressionOperation ::= nonNumericCapturePrefixOperator captureExpressionOperand |
                               matchedExpressionInMatchExpressionOperation
// unlike captureMatchedExpressionOperation, guarantees the capturePrefixOperator is present
captureExpressionPrefixOperation ::= nonNumericCapturePrefixOperator captureExpressionOperand
                                     { extends =  captureExpressionOperation }

private captureMatchedExpressionOperand ::= captureMatchedExpressionPrefixOperation | matchedExpressionInMatchMatchedExpressionOperation
captureMatchedExpressionOperation ::= nonNumericCapturePrefixOperator captureMatchedExpressionOperand |
                                      matchedExpressionInMatchMatchedExpressionOperation
                                      { extends = captureExpressionOperation }
// unlike captureMatchedExpressionOperation, guarantees the capturePrefixOperator is present
captureMatchedExpressionPrefixOperation ::= nonNumericCapturePrefixOperator captureMatchedExpressionOperand
                                            { extends = captureMatchedExpressionOperation }

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L51)
inMatchInfixOperator ::= EOL* IN_MATCH_OPERATOR EOL* { name = "<-, \\\\" }

private matchedExpressionInMatchExpressionOperand ::= captureExpressionPrefixOperation | matchedExpressionWhenExpressionOperation
matchedExpressionInMatchExpressionOperation ::= matchedExpressionInMatchMatchedExpressionOperation (inMatchInfixOperator matchedExpressionInMatchExpressionOperand)? |
                                                matchedExpressionInMatchExpressionOperand
                                                { extends = captureExpressionOperation }

private matchedExpressionInMatchMatchedExpressionOperand ::= captureMatchedExpressionPrefixOperation | matchedExpressionWhenMatchedExpressionOperation
matchedExpressionInMatchMatchedExpressionOperation ::= matchedExpressionInMatchMatchedExpressionOperand (inMatchInfixOperator matchedExpressionInMatchMatchedExpressionOperand)*
                                                       { extends = matchedExpressionInMatchedExpressionOperation }

// right-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L52)
whenInfixOperator ::= EOL* WHEN_OPERATOR EOL* { name = "when" }

private matchedExpressionWhenExpressionOperand ::= captureExpressionPrefixOperation | matchedExpressionTypeExpressionOperation
matchedExpressionWhenExpressionOperation ::= matchedExpressionWhenMatchedExpressionOperation (whenInfixOperator matchedExpressionWhenExpressionOperation)? |
                                             matchedExpressionWhenExpressionOperand
                                             { extends = matchedExpressionInMatchExpressionOperation }

private matchedExpressionWhenMatchedExpressionOperand ::= captureMatchedExpressionPrefixOperation | matchedExpressionTypeMatchedExpressionOperation
matchedExpressionWhenMatchedExpressionOperation ::= matchedExpressionWhenMatchedExpressionOperand (whenInfixOperator matchedExpressionWhenMatchedExpressionOperation)?
                                                    { extends = matchedExpressionWhenExpressionOperation }

// right-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L53)
typeInfixOperator ::= EOL* TYPE_OPERATOR EOL* { name = "::" }

private matchedExpressionTypeExpressionOperand ::= captureExpressionPrefixOperation | matchedExpressionPipeExpressionOperation
matchedExpressionTypeExpressionOperation ::= matchedExpressionTypeMatchedExpressionOperation (typeInfixOperator matchedExpressionTypeExpressionOperation)? |
                                             matchedExpressionTypeExpressionOperand
                                             { extends = matchedExpressionWhenExpressionOperation }

private matchedExpressionTypeMatchedExpressionOperand ::= captureMatchedExpressionPrefixOperation | matchedExpressionPipeMatchedExpressionOperation
matchedExpressionTypeMatchedExpressionOperation ::= matchedExpressionTypeMatchedExpressionOperand (typeInfixOperator matchedExpressionTypeMatchedExpressionOperation)?
                                                    { extends = matchedExpressionTypeExpressionOperation }

// right-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L54)
pipeInfixOperator ::= EOL* PIPE_OPERATOR EOL* { name = "|" }

private matchedExpressionPipeExpressionOperand ::= captureExpressionPrefixOperation | matchedExpressionMatchExpressionOperation
matchedExpressionPipeExpressionOperation ::= matchedExpressionPipeMatchedExpressionOperation (pipeInfixOperator matchedExpressionPipeExpressionOperation)? |
                                             matchedExpressionPipeExpressionOperand
                                             { extends = matchedExpressionTypeExpressionOperation }

private matchedExpressionPipeMatchedExpressionOperand ::= captureMatchedExpressionPrefixOperation | matchedExpressionMatchMatchedExpressionOperation
matchedExpressionPipeMatchedExpressionOperation ::= matchedExpressionPipeMatchedExpressionOperand (pipeInfixOperator matchedExpressionPipeMatchedExpressionOperation)?
                                                    { extends = matchedExpressionPipeExpressionOperation }

// right-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L56)
matchInfixOperator ::= EOL* MATCH_OPERATOR EOL* { name = "=" }

private matchedExpressionMatchExpressionOperand ::= captureExpressionPrefixOperation | matchedExpressionOrExpressionOperation
matchedExpressionMatchExpressionOperation ::= matchedExpressionMatchMatchedExpressionOperation (matchInfixOperator matchedExpressionOrExpressionOperation)? |
                                              matchedExpressionMatchExpressionOperand
                                              { extends = matchedExpressionPipeExpressionOperation }

private matchedExpressionMatchMatchedExpressionOperand ::= captureMatchedExpressionPrefixOperation | matchedExpressionOrMatchedExpressionOperation
matchedExpressionMatchMatchedExpressionOperation ::= matchedExpressionMatchMatchedExpressionOperand (matchInfixOperator matchedExpressionMatchMatchedExpressionOperation)?
                                                     { extends = matchedExpressionMatchExpressionOperation }

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L57)
orInfixOperator ::= EOL* OR_OPERATOR EOL* { name = "||, |||, or" }

private matchedExpressionOrExpressionOperand ::= captureExpressionPrefixOperation | matchedExpressionAndExpressionOperation
matchedExpressionOrExpressionOperation ::= matchedExpressionOrMatchedExpressionOperation (orInfixOperator matchedExpressionOrExpressionOperand)? |
                                           matchedExpressionOrExpressionOperand
                                           { extends = matchedExpressionMatchExpressionOperation }

private matchedExpressionOrMatchedExpressionOperand ::= captureMatchedExpressionPrefixOperation | matchedExpressionAndMatchedExpressionOperation
matchedExpressionOrMatchedExpressionOperation ::= matchedExpressionOrMatchedExpressionOperand (orInfixOperator matchedExpressionOrMatchedExpressionOperand)*
                                                  { extends = matchedExpressionOrExpressionOperation }

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L58)
andInfixOperator ::= EOL* AND_OPERATOR EOL* { name = "&&, &&&, and" }

private matchedExpressionAndExpressionOperand ::= captureExpressionPrefixOperation | matchedExpressionComparisonExpressionOperation
matchedExpressionAndExpressionOperation ::= matchedExpressionAndMatchedExpressionOperation (andInfixOperator matchedExpressionAndExpressionOperand)? |
                                            matchedExpressionAndExpressionOperand
                                            { extends = matchedExpressionOrExpressionOperation }

private matchedExpressionAndMatchedExpressionOperand ::= captureMatchedExpressionPrefixOperation | matchedExpressionComparisonMatchedExpressionOperation
matchedExpressionAndMatchedExpressionOperation ::= matchedExpressionAndMatchedExpressionOperand (andInfixOperator matchedExpressionAndMatchedExpressionOperand)*
                                                   { extends = matchedExpressionAndExpressionOperation }

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L59)
comparisonInfixOperator ::= EOL* COMPARISON_OPERATOR EOL* { name = "!=, ==, =~, !==, ===" }

private matchedExpressionComparisonExpressionOperand ::= captureExpressionPrefixOperation | matchedExpressionRelationalExpressionOperation
matchedExpressionComparisonExpressionOperation ::= matchedExpressionComparisonMatchedExpressionOperation (comparisonInfixOperator matchedExpressionComparisonExpressionOperand)? |
                                                   matchedExpressionComparisonExpressionOperand
                                                   { extends = matchedExpressionAndExpressionOperation }

private matchedExpressionComparisonMatchedExpressionOperand ::= captureMatchedExpressionPrefixOperation | matchedExpressionRelationalMatchedExpressionOperation
matchedExpressionComparisonMatchedExpressionOperation ::= matchedExpressionComparisonMatchedExpressionOperand (comparisonInfixOperator matchedExpressionComparisonMatchedExpressionOperand)*
                                                          { extends = matchedExpressionComparisonExpressionOperation }

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L60)
relationalInfixOperator ::= EOL* RELATIONAL_OPERATOR EOL* { name = "<, >, <=, >=" }

private matchedExpressionRelationalExpressionOperand ::= captureExpressionPrefixOperation | matchedExpressionArrowExpressionOperation
matchedExpressionRelationalExpressionOperation ::= matchedExpressionRelationalMatchedExpressionOperation (relationalInfixOperator matchedExpressionRelationalExpressionOperand)? |
                                                   matchedExpressionRelationalExpressionOperand
                                                   { extends = matchedExpressionComparisonExpressionOperation }

private matchedExpressionRelationalMatchedExpressionOperand ::= captureMatchedExpressionPrefixOperation | matchedExpressionArrowMatchedExpressionOperation
matchedExpressionRelationalMatchedExpressionOperation ::= matchedExpressionRelationalMatchedExpressionOperand (relationalInfixOperator matchedExpressionRelationalMatchedExpressionOperand)*
                                                          { extends = matchedExpressionRelationalExpressionOperation }

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L61)
arrowInfixOperator ::= EOL* ARROW_OPERATOR EOL* { name = "<~, |>, ~>, <<<, <<~, <|>, <~>, >>>, ~>>" }

private matchedExpressionArrowExpressionOperand ::= captureExpressionPrefixOperation | matchedExpressionInExpressionOperation
matchedExpressionArrowExpressionOperation ::= matchedExpressionArrowMatchedExpressionOperation (arrowInfixOperator matchedExpressionArrowExpressionOperand)? |
                                              matchedExpressionArrowExpressionOperand
                                              { extends = matchedExpressionRelationalExpressionOperation }

private matchedExpressionArrowMatchedExpressionOperand ::= captureMatchedExpressionPrefixOperation | matchedExpressionInMatchedExpressionOperation
matchedExpressionArrowMatchedExpressionOperation ::= matchedExpressionArrowMatchedExpressionOperand (arrowInfixOperator matchedExpressionArrowMatchedExpressionOperand)*
                                                     { extends = matchedExpressionArrowExpressionOperation }

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L62)
inInfixOperator ::= EOL* IN_OPERATOR EOL* { name = "in" }

private matchedExpressionInExpressionOperand ::= captureExpressionPrefixOperation | matchedExpressionTwoExpressionOperation
matchedExpressionInExpressionOperation ::= matchedExpressionInMatchedExpressionOperation (inInfixOperator matchedExpressionInExpressionOperand)? |
                                           matchedExpressionInExpressionOperand
                                           { extends = matchedExpressionArrowExpressionOperation }

private matchedExpressionInMatchedExpressionOperand ::= captureMatchedExpressionPrefixOperation | matchedExpressionTwoMatchedExpressionOperation
matchedExpressionInMatchedExpressionOperation ::= matchedExpressionInMatchedExpressionOperand (inInfixOperator matchedExpressionInMatchedExpressionOperand)*
                                                  { extends = matchedExpressionInExpressionOperation }

// right-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L63)
twoInfixOperator ::= EOL* TWO_OPERATOR EOL* { name = "++, --, .., <>" }

private matchedExpressionTwoExpressionOperand ::= captureExpressionPrefixOperation | matchedExpressionAdditionExpressionOperation
matchedExpressionTwoExpressionOperation ::= matchedExpressionTwoMatchedExpressionOperation (twoInfixOperator matchedExpressionTwoExpressionOperand)? |
                                            matchedExpressionTwoExpressionOperand
                                            { extends = matchedExpressionInExpressionOperation }

private matchedExpressionTwoMatchedExpressionOperand ::= captureMatchedExpressionPrefixOperation | matchedExpressionAdditionMatchedExpressionOperation
matchedExpressionTwoMatchedExpressionOperation ::= matchedExpressionTwoMatchedExpressionOperand (twoInfixOperator matchedExpressionTwoMatchedExpressionOperation)?
                                                   { extends = matchedExpressionTwoExpressionOperation }

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L64)
/* Unlike other binary operation, additionOperations cannot begin with EOLs: if there are EOLs, then the +/-
   is interpreted as captureOperation */
additionInfixOperator ::= DUAL_OPERATOR EOL* { name = "+, -" }

private matchedExpressionAdditionExpressionOperand ::= captureExpressionPrefixOperation | matchedExpressionMultiplicationExpressionOperation
matchedExpressionAdditionExpressionOperation ::= matchedExpressionAdditionMatchedExpressionOperation (additionInfixOperator matchedExpressionAdditionExpressionOperand)? |
                                                 matchedExpressionAdditionExpressionOperand
                                                 { extends = matchedExpressionTwoExpressionOperation }

private matchedExpressionAdditionMatchedExpressionOperand ::= captureMatchedExpressionPrefixOperation | matchedExpressionMultiplicationMatchedExpressionOperation                                         
/* used both here and in noParenthesesOneExpression to disambiguate `IDENTIFIER captureMatchedExpressionOperation` from
   `IDENTIFIER DUAL_OPERATOR EOL* matchedExpressionMultiplicationMatchedExpressionOperation` */
private matchedExpressionAdditionMatchedExpressionOperationTail ::= additionInfixOperator matchedExpressionAdditionMatchedExpressionOperand
matchedExpressionAdditionMatchedExpressionOperation ::= matchedExpressionAdditionMatchedExpressionOperand matchedExpressionAdditionMatchedExpressionOperationTail*
                                                        { extends = matchedExpressionAdditionExpressionOperation }

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L65)
multiplicationInfixOperator ::= EOL* MULTIPLICATION_OPERATOR EOL* { name = "*, /" }

private matchedExpressionMultiplicationExpressionOperand ::= captureExpressionPrefixOperation | matchedExpressionHatExpressionOperation
matchedExpressionMultiplicationExpressionOperation ::= matchedExpressionMultiplicationMatchedExpressionOperation (multiplicationInfixOperator matchedExpressionMultiplicationExpressionOperand)? |
                                                       matchedExpressionMultiplicationExpressionOperand
                                                       { extends = matchedExpressionAdditionExpressionOperation }

private matchedExpressionMultiplicationMatchedExpressionOperand ::= captureMatchedExpressionPrefixOperation | matchedExpressionHatMatchedExpressionOperation
matchedExpressionMultiplicationMatchedExpressionOperation ::= matchedExpressionMultiplicationMatchedExpressionOperand (multiplicationInfixOperator matchedExpressionMultiplicationMatchedExpressionOperand)*
                                                              { extends = matchedExpressionMultiplicationExpressionOperation }

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L66)
hatInfixOperator ::= EOL* HAT_OPERATOR EOL* { name = "^^^" }

private matchedExpressionHatExpressionOperand ::= captureExpressionPrefixOperation | unaryExpressionOperation
matchedExpressionHatExpressionOperation ::= matchedExpressionHatMatchedExpressionOperation (hatInfixOperator matchedExpressionHatExpressionOperand)? |
                                            matchedExpressionHatExpressionOperand
                                            { extends = matchedExpressionMultiplicationExpressionOperation }

private matchedExpressionHatMatchedExpressionOperand ::= captureMatchedExpressionPrefixOperation | unaryMatchedExpressionOperation
matchedExpressionHatMatchedExpressionOperation ::= matchedExpressionHatMatchedExpressionOperand (hatInfixOperator matchedExpressionHatMatchedExpressionOperand)*
                                                   { extends = matchedExpressionHatExpressionOperation }

// non-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L67)
unaryPrefixOperator ::= (DUAL_OPERATOR | UNARY_OPERATOR) EOL* { name = "+, -, !, ^, not, ~~~" }

/*
 * Must include prefix operations of higher precedence as prefix operations are allowed to be nested without parentheses
 * just due to the nature of prefixing.
 */
private unaryExpressionOperand ::= captureExpressionPrefixOperation | unaryExpressionPrefixOperation | atExpressionOperation
unaryExpressionOperation ::= unaryExpressionPrefixOperation |
                             atExpressionOperation
                             { extends = matchedExpressionHatExpressionOperation }
// unlike unaryMatchedExpressionOperation, guarantees the unaryPrefixOperator is present
unaryExpressionPrefixOperation ::= unaryPrefixOperator unaryExpressionOperand { extends = unaryExpressionOperation }

/*
 # Must include prefix operations of higher precedence as prefix operations are allowed to be nested without parentheses just due to the nature of prefixing.
 */
private unaryMatchedExpressionOperand ::= captureMatchedExpressionPrefixOperation | unaryMatchedExpressionPrefixOperation | atMatchedExpressionOperation
unaryMatchedExpressionOperation ::= unaryMatchedExpressionPrefixOperation |
                                    atMatchedExpressionOperation
                                    { extends = unaryExpressionOperation }
// unlike unaryMatchedExpressionOperation, guarantees the unaryPrefixOperator is present
unaryMatchedExpressionPrefixOperation ::= unaryPrefixOperator unaryMatchedExpressionOperand { extends = unaryMatchedExpressionOperation }

// non-associative (https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L70)
atPrefixOperator ::= AT_OPERATOR EOL* { name = "@" }

private atExpressionOperand ::= captureExpressionPrefixOperation | unaryExpressionPrefixOperation | atExpressionPrefixOperation | tailExpression
atExpressionOperation ::= atExpressionPrefixOperation |
                          tailExpression
                          { extends = unaryExpressionOperation }
atExpressionPrefixOperation ::= atPrefixOperator atExpressionOperand { extends = atExpressionOperation }

/*
 # Must include prefix operations of higher precedence as prefix operations are allowed to be nested without parentheses just due to the nature of prefixing.
 */
private atMatchedExpressionOperand ::= captureMatchedExpressionPrefixOperation | unaryMatchedExpressionPrefixOperation | atMatchedExpressionPrefixOperation | matchedExpression
atMatchedExpressionOperation ::= atMatchedExpressionPrefixOperation |
                                 matchedExpression
                                 { extends = atExpressionOperation }
atMatchedExpressionPrefixOperation ::= atPrefixOperator atMatchedExpressionOperand
                                       { extends = atMatchedExpressionOperation }

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L69)
infixDotOperator ::= EOL* DOT_OPERATOR EOL* { name = "." }
private headQualifier ::= atPrefixOperator (ALIAS | IDENTIFIER) |
                          atCharTokenOrNumberOperation |
                          captureCharTokenOrNumberOperation |
                          unaryCharTokenOrNumberOperation |
                          OPENING_PARENTHESIS infixSemicolon CLOSING_PARENTHESIS |
                          charTokenOrNumber |
                          list |
                          sigil |
                          atom
qualifiedIdentifier ::= qualifier IDENTIFIER
private qualifier ::= (headQualifier infixDotOperator)? (middleQualifier infixDotOperator)*
// TODO add operators
private middleQualifier ::= binaryString |
                           listString |
                           FALSE |
                           NIL |
                           TRUE |
                           IDENTIFIER |
                           ALIAS
qualifiedAlias ::= qualifier ALIAS

matchedExpression ::= noParenthesesOneExpression |
                      accessExpression
                      { extends = atMatchedExpressionOperation }
tailExpression ::= emptyParentheses |
                   noParenthesesCall
                   { extends = atExpressionOperation }

noParenthesesOneExpression ::= qualifiedIdentifier !callArgumentsNoParenthesesManyStrict
accessExpression ::= atCharTokenOrNumberOperation |
                     captureCharTokenOrNumberOperation |
                     unaryCharTokenOrNumberOperation |
                     OPENING_PARENTHESIS infixSemicolon CLOSING_PARENTHESIS |
                     charTokenOrNumber |
                     list |
                     binaryString |
                     listString |
                     sigil |
                     FALSE |
                     NIL |
                     TRUE |
                     maxExpression
noParenthesesCall ::= qualifiedIdentifier callArgumentsNoParenthesesManyStrict

atCharTokenOrNumberOperation ::= atPrefixOperator charTokenOrNumber
captureCharTokenOrNumberOperation ::= capturePrefixOperator charTokenOrNumber
unaryCharTokenOrNumberOperation ::= unaryPrefixOperator charTokenOrNumber

/* elixir_tokenizer.erl converts CHAR_TOKENs to their number representation, so `number` in elixir_parser.yrl matches
   Elixir.flex's NUMBER and CHAR_TOKEN. */
private charTokenOrNumber ::= CHAR_TOKEN | number

maxExpression ::= qualifiedAlias |
                  // Must be after qualifiedAlias because atom can start qualifiedAlias
                  atom

/* Special class for wrapping rules so that
   {@link: org.elixir_lang.inspection.NoParenthesesStrict} can just search for
   ElixirNoParenthesesStrict instead of having to differentiate between valid and invalid
   rule classes. */
noParenthesesStrict ::= emptyParentheses |
                        OPENING_PARENTHESIS (
                                             callArgumentsNoParenthesesKeywords |
                                             callArgumentsNoParenthesesMany
                                            ) CLOSING_PARENTHESIS
/* Special class for wrapping noParenthesesCall so that
   {@link: org.elixir_lang.inspection.NoParenthesesManyStrict} can just search for
   ElixirNoParenthesesManyStrictNoParenthesesExpression isn't of having to differentiate between valid and invalid
   ElixirNoParenthesesCall. */
noParenthesesManyStrictNoParenthesesExpression ::= noParenthesesCall

//noParenthesesOneExpression ::= dotIdentifier

number ::= binaryWholeNumber |
           decimalNumber |
           hexadecimalWholeNumber |
           octalWholeNumber |
           unknownBaseWholeNumber
/*
 * Number Operations - Used in accessExpression
 */

octalWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX OCTAL_WHOLE_NUMBER_BASE (INVALID_OCTAL_DIGITS | VALID_OCTAL_DIGITS)+ { pin=2 }

private quote ::= (charList | string)
sigil ::= interpolatedCharListSigil |
          interpolatedHeredocCharListSigil |
          interpolatedHeredocRegex |
          interpolatedHeredocSigil |
          interpolatedHeredocStringSigil |
          interpolatedHeredocWords |
          interpolatedRegex |
          interpolatedSigil |
          interpolatedStringSigil |
          literalCharListSigil |
          literalHeredocRegex |
          literalHeredocSigil |
          literalHeredocStringSigil |
          literalHeredocWords |
          literalRegex |
          literalSigil |
          literalStringSigil |
          literalWords
string ::= STRING_PROMOTER
           interpolatedStringBody
           STRING_TERMINATOR
stringHeredoc ::= STRING_HEREDOC_PROMOTER EOL
                  interpolatedStringBody
                  STRING_HEREDOC_TERMINATOR

unknownBaseWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX UNKNOWN_WHOLE_NUMBER_BASE INVALID_UNKNOWN_BASE_DIGITS+ { pin=2 }
