{
  parserClass="org.elixir_lang.parser.ElixirParser"

 extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  /*
   * Ordered by rule being extended (extends(regex)=<rule-begin-extended)
   */

  extends("emptyParentheses|(matched|noParentheses)Expression")=expression
  extends("charList(Heredoc)?|maxExpression|number.*Operation|number|list|sigil|string(Heredoc)?")=matchedExpressionAccessExpression
  extends("decimal(Float|WholeNUmber)")=decimalNumber
  extends("identifierExpression|matchedExpression.*|noParenthesesOneExpression")=matchedExpression
  extends("atom|dotAlias")=matchedExpressionMaxExpression
  extends("(.*Whole|decimal)Number")=number

  psiClassPrefix="Elixir"
  psiImplClassSuffix="Impl"
  psiPackage="org.elixir_lang.psi"
  psiImplPackage="org.elixir_lang.psi.impl"

  elementTypeHolderClass="org.elixir_lang.psi.ElixirTypes"
  elementTypeClass="org.elixir_lang.psi.ElixirElementType"
  tokenTypeClass="org.elixir_lang.psi.ElixirTokenType"

  tokens = [
    BASE_WHOLE_NUMBER_PREFIX = "0"
    BINARY_WHOLE_NUMBER_BASE = "b"
    CLOSING_BRACKET = "]"
    // TODO remove once CLOSING_PARENTHESIS is used in emptyParentheses rule
    CLOSING_PARENTHESIS = ")"
    COMMA = ","
    COMMENT = "regexp:#[^\r\n]*(\n|\r|\r\n)?"
    DECIMAL_MARK = "."
    DECIMAL_SEPARATOR = "_"
    DOT_OPERATOR = "."
    END = "end"
    FALSE = "false"
    FN = "fn"
    HEXADECIMAL_WHOLE_NUMBER_BASE = "x"
    IN_OPERATOR = "in"
    INVALID_BINARY_DIGITS = "regexp:[A-Za-z2-9]+"
    INVALID_UNKNOWN_BASE_DIGITS = "regexp:[A-Za-z0-9]+"
    NIL = "nil"
    OBSOLETE_BINARY_WHOLE_NUMBER_BASE = "B"
    OBSOLETE_HEXADECIMAL_WHOLE_NUMBER_BASE = "X"
    OCTAL_WHOLE_NUMBER_BASE = "o"
    OPENING_BRACKET = "["
    // TODO remove once OPENING_PARENTHESIS is used in emptyParentheses rule
    OPENING_PARENTHESIS = "("
    // TOO remove once SEMICOLON is used in endOfExpression rule
    SEMICOLON = ";"
    // TODO remove once containers are available for `{}` after alias for empty structs
    STRUCT_OPERATOR = "%"
    TRUE = "true"
    UNKNOWN_WHOLE_NUMBER_BASE = "regexp:A-Zac-z"
    VALID_BINARY_DIGITS = "regexp:[01]+"
    VALID_HEXADECIMAL_DIGITS = "regexp:[A-Fa-f0-9]+"
  ]
}

// expressionList is optional to handle code-less file that contains only EOL between blank lines and order comment
// lines
elixirFile ::= endOfExpression* (expressionList endOfExpression*)?

/*
 * In alphabetical order
 */

atom ::= COLON (ATOM_FRAGMENT | quote)
binaryWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX (BINARY_WHOLE_NUMBER_BASE | OBSOLETE_BINARY_WHOLE_NUMBER_BASE) (INVALID_BINARY_DIGITS | VALID_BINARY_DIGITS)+ { pin=2 }
private binaryString ::= string | stringHeredoc
private callArgumentsNoParenthesesExpression ::= matchedExpression |
                                                 emptyParentheses
callArgumentsNoParenthesesKeywords ::= callArgumentsNoParenthesesKeywordsExpression (COMMA EOL* callArgumentsNoParenthesesKeywordsExpression)*
callArgumentsNoParenthesesKeywordsExpression ::= keywordKeyColonEOL callArgumentsNoParenthesesExpression
callArgumentsNoParenthesesMany ::= matchedExpression COMMA EOL* callArgumentsNoParenthesesKeywords
private callArgumentsNoParenthesesManyStrict ::= callArgumentsNoParenthesesMany
charList ::= CHAR_LIST_PROMOTER
             interpolatedCharListBody
             CHAR_LIST_TERMINATOR
charListHeredoc ::= CHAR_LIST_HEREDOC_PROMOTER EOL
                    interpolatedCharListBody
                    CHAR_LIST_HEREDOC_TERMINATOR
private containerExpression ::= emptyParentheses
decimalFloat ::= decimalWholeNumber DECIMAL_MARK decimalWholeNumber (EXPONENT_MARK DUAL_OPERATOR? decimalWholeNumber)?
decimalWholeNumber ::= {VALID_DECIMAL_DIGITS} ({DECIMAL_SEPARATOR}? (INVALID_DECIMAL_DIGITS | VALID_DECIMAL_DIGITS))*
// decimalFloat starts with decimalWholeNumber, so decimalFloat needs to be first
decimalNumber ::= decimalFloat |
                  decimalWholeNumber
emptyParentheses ::= OPENING_PARENTHESIS EOL* CLOSING_PARENTHESIS
// Must have at least one EOL or SEMICOLON, but at most one SEMICOLON
endOfExpression ::= EOL* SEMICOLON EOL* | EOL
expression ::= emptyParentheses |
               /* Must be before matchedExpression because noParenthesesExpression is
                  `matchedExpressionDotIdentifier callArgumentsNoParenthesesManyStrict` which is longer than
                  `matchedExpressionDotIdentifier` in matchedExpression. */
               noParenthesesExpression |
               matchedExpression
private expressionList ::= expression (endOfExpression+ expression)*
hexadecimalWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX (HEXADECIMAL_WHOLE_NUMBER_BASE | OBSOLETE_HEXADECIMAL_WHOLE_NUMBER_BASE) (INVALID_HEXADECIMAL_DIGITS | VALID_HEXADECIMAL_DIGITS)+ { pin=2 }
identifierExpression ::= IDENTIFIER
private interpolatedCharListSigil ::= TILDE INTERPOLATING_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_PROMOTER interpolatedCharListBody CHAR_LIST_SIGIL_TERMINATOR
private interpolatedCharListBody ::= (interpolation | CHAR_LIST_FRAGMENT | VALID_ESCAPE_SEQUENCE)*
private interpolatedHeredocCharListSigil ::= TILDE INTERPOLATING_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_HEREDOC_PROMOTER EOL
                                             interpolatedCharListBody
                                             CHAR_LIST_SIGIL_HEREDOC_TERMINATOR
private interpolatedHeredocRegex ::= TILDE INTERPOLATING_REGEX_SIGIL_NAME REGEX_HEREDOC_PROMOTER EOL
                                     interpolatedRegexBody
                                     REGEX_HEREDOC_TERMINATOR SIGIL_MODIFIER*
private interpolatedHeredocSigil ::= TILDE INTERPOLATING_SIGIL_NAME SIGIL_HEREDOC_PROMOTER EOL
                                     interpolatedSigilBody
                                     SIGIL_HEREDOC_PROMOTER SIGIL_MODIFIER*
private interpolatedHeredocStringSigil ::= TILDE INTERPOLATING_STRING_SIGIL_NAME STRING_SIGIL_HEREDOC_PROMOTER EOL
                                           interpolatedStringBody
                                           STRING_SIGIL_HEREDOC_TERMINATOR
private interpolatedHeredocWords ::= TILDE INTERPOLATING_WORDS_SIGIL_NAME WORDS_HEREDOC_PROMOTER EOL
                                     interpolatedWordsBody
                                     WORDS_HEREDOC_TERMINATOR SIGIL_MODIFIER*
private interpolatedRegex ::= TILDE INTERPOLATING_REGEX_SIGIL_NAME REGEX_PROMOTER interpolatedRegexBody REGEX_TERMINATOR SIGIL_MODIFIER*
private interpolatedRegexBody ::= (interpolation | REGEX_FRAGMENT | VALID_ESCAPE_SEQUENCE)*
private interpolatedSigil ::= TILDE INTERPOLATING_SIGIL_NAME SIGIL_PROMOTER interpolatedSigilBody SIGIL_TERMINATOR SIGIL_MODIFIER*
private interpolatedSigilBody ::= (interpolation | SIGIL_FRAGMENT | VALID_ESCAPE_SEQUENCE)*
private interpolatedStringSigil ::= TILDE INTERPOLATING_STRING_SIGIL_NAME STRING_SIGIL_PROMOTER interpolatedStringBody STRING_SIGIL_TERMINATOR
private interpolatedStringBody ::=  (interpolation | STRING_FRAGMENT | VALID_ESCAPE_SEQUENCE)*
private interpolatedWordsBody ::= (interpolation | WORDS_FRAGMENT | VALID_ESCAPE_SEQUENCE)*
interpolation ::= INTERPOLATION_START expressionList? INTERPOLATION_END
keywordKey ::= ALIAS |
               AND_OPERATOR |
               ARROW_OPERATOR |
               ASSOCIATION_OPERATOR |
               AT_OPERATOR |
               BIT_STRING_OPERATOR |
               CAPTURE_OPERATOR |
               COMPARISON_OPERATOR |
               DUAL_OPERATOR |
               HAT_OPERATOR |
               IDENTIFIER |
               IN_MATCH_OPERATOR |
               IN_OPERATOR |
               MAP_OPERATOR |
               MATCH_OPERATOR |
               MULTIPLICATION_OPERATOR |
               OR_OPERATOR |
               PIPE_OPERATOR |
               RELATIONAL_OPERATOR |
               STAB_OPERATOR |
               STRUCT_OPERATOR |
               TUPLE_OPERATOR |
               TWO_OPERATOR |
               UNARY_OPERATOR |
               WHEN_OPERATOR |
               quote
private keywordKeyColonEOL ::= keywordKey KEYWORD_PAIR_COLON EOL*
keywordPair ::=  keywordKeyColonEOL keywordValue
keywordValue ::= containerExpression
list ::= OPENING_BRACKET EOL* (keywordPair (COMMA EOL* keywordPair)* COMMA?)? CLOSING_BRACKET
private listString ::= charList | charListHeredoc
private literalCharListBody ::= CHAR_LIST_FRAGMENT*
private literalCharListSigil ::= TILDE LITERAL_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_PROMOTER literalCharListBody CHAR_LIST_SIGIL_TERMINATOR
private literalHeredocRegex ::= TILDE LITERAL_REGEX_SIGIL_NAME REGEX_HEREDOC_PROMOTER EOL
                                literalRegexBody
                                REGEX_HEREDOC_TERMINATOR SIGIL_MODIFIER*
private literalHeredocSigil ::= TILDE LITERAL_SIGIL_NAME SIGIL_HEREDOC_PROMOTER EOL
                                literalSigilBody
                                SIGIL_HEREDOC_TERMINATOR SIGIL_MODIFIER*
private literalHeredocStringSigil ::= TILDE LITERAL_STRING_SIGIL_NAME STRING_SIGIL_HEREDOC_PROMOTER EOL
                                      literalStringBody
                                      STRING_SIGIL_HEREDOC_TERMINATOR
private literalHeredocWords ::= TILDE LITERAL_WORDS_SIGIL_NAME WORDS_HEREDOC_PROMOTER EOL
                                literalWordsBody
                                WORDS_HEREDOC_TERMINATOR SIGIL_MODIFIER*
private literalRegex ::= TILDE LITERAL_SIGIL_NAME REGEX_PROMOTER literalRegexBody REGEX_TERMINATOR SIGIL_MODIFIER*
private literalRegexBody ::= REGEX_FRAGMENT*
private literalSigil ::= TILDE LITERAL_SIGIL_NAME SIGIL_PROMOTER literalSigilBody SIGIL_TERMINATOR SIGIL_MODIFIER*
private literalSigilBody ::= SIGIL_FRAGMENT*
private literalStringBody ::= STRING_FRAGMENT*
private literalStringSigil ::= TILDE LITERAL_STRING_SIGIL_NAME STRING_SIGIL_PROMOTER literalStringBody STRING_SIGIL_TERMINATOR
private literalWords ::=  TILDE LITERAL_SIGIL_NAME WORDS_PROMOTER literal WORDS_TERMINATOR SIGIL_MODIFIER*
private literalWordsBody ::= WORDS_FRAGMENT*

/* order of choices is lower precedence first as lower precedence operation are meant to enclose higher precedence
   operators.
   @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L44-L71 */
matchedExpression ::= matchedExpressionCaptureOperation |
                      matchedExpressionInMatchOperation |
                      matchedExpressionWhenOperation |
                      matchedExpressionTypeOperation |
                      matchedExpressionPipeOperation |
                      matchedExpressionMatchOperation |
                      matchedExpressionOrOperation |
                      matchedExpressionAndOperation |
                      matchedExpressionComparisonOperation |
                      matchedExpressionRelationalOperation |
                      matchedExpressionArrowOperation |
                      matchedExpressionInOperation |
                      matchedExpressionTwoOperation |
                      matchedExpressionAdditionOperation |
                      matchedExpressionMultiplicationOperation |
                      matchedExpressionHatOperation |
                      matchedExpressionUnaryOperation |
                      matchedExpressionDotAlias |
                      matchedExpressionDotIdentifier |
                      matchedExpressionAtOperation |
                      identifierExpression |
                      matchedExpressionAccessExpression
// Specialized for matchedExpression because max_expr had to be specialized to matchedExpressionMaxExpression
matchedExpressionAccessExpression ::= numberCaptureOperation |
                                      numberUnaryOperation |
                                      numberAtOperation |
                                      OPENING_PARENTHESIS EOL* SEMICOLON EOL* CLOSING_PARENTHESIS |
                                      /* elixir_tokenizer.erl converts CHAR_TOKENs to their number representation, so `number` in
                                         elixir_parser.yrl matches Elixir.flex's NUMBER and CHAR_TOKEN. */
                                      CHAR_TOKEN |
                                      number |
                                      list |
                                      binaryString |
                                      listString |
                                      sigil |
                                      FALSE |
                                      NIL |
                                      TRUE |
                                      matchedExpressionMaxExpression

/* Unlike other binary operation, additionOperations cannot begin with EOLs: if there are EOLs, then the +/-
   is interpreted as unaryOperation */
matchedExpressionAdditionOperation ::= matchedExpression DUAL_OPERATOR EOL* matchedExpression
matchedExpressionAndOperation ::= matchedExpression EOL* AND_OPERATOR EOL* matchedExpression
matchedExpressionArrowOperation ::= matchedExpression EOL* ARROW_OPERATOR EOL* matchedExpression
matchedExpressionAtOperation ::= AT_OPERATOR EOL* matchedExpression
matchedExpressionCaptureOperation ::= CAPTURE_OPERATOR EOL* matchedExpression
matchedExpressionComparisonOperation ::= matchedExpression EOL* COMPARISON_OPERATOR EOL* matchedExpression
matchedExpressionDotAlias ::= matchedExpression EOL* DOT_OPERATOR EOL* ALIAS
matchedExpressionDotIdentifier ::= matchedExpression EOL* DOT_OPERATOR EOL* IDENTIFIER
matchedExpressionHatOperation ::= matchedExpression EOL* HAT_OPERATOR EOL* matchedExpression
matchedExpressionInMatchOperation ::= matchedExpression EOL* IN_MATCH_OPERATOR EOL* matchedExpression
matchedExpressionInOperation ::= matchedExpression EOL* IN_OPERATOR EOL* matchedExpression
matchedExpressionMatchOperation ::= matchedExpression EOL* MATCH_OPERATOR EOL* matchedExpression { rightAssociative = true }
/* Specialized for matchedExpression to eliminate left-recursion from max_expr when dot_alias is a child instead of
   matchedExpressionDotAlias being a direct child of matchedExpression */
matchedExpressionMaxExpression ::= atom |
                                   ALIAS
matchedExpressionMultiplicationOperation ::= matchedExpression EOL* MULTIPLICATION_OPERATOR EOL* matchedExpression
matchedExpressionOrOperation ::= matchedExpression EOL* OR_OPERATOR EOL* matchedExpression
matchedExpressionPipeOperation ::= matchedExpression EOL* PIPE_OPERATOR EOL* matchedExpression { rightAssociative = true }
matchedExpressionRelationalOperation ::= matchedExpression EOL* RELATIONAL_OPERATOR EOL* matchedExpression
matchedExpressionTwoOperation ::= matchedExpression EOL* TWO_OPERATOR EOL* matchedExpression { rightAssociative = true }
matchedExpressionTypeOperation ::= matchedExpression EOL* TYPE_OPERATOR EOL* matchedExpression { rightAssociative = true }
matchedExpressionUnaryOperation ::= (DUAL_OPERATOR | UNARY_OPERATOR) EOL* matchedExpression
matchedExpressionWhenOperation ::= matchedExpression EOL* WHEN_OPERATOR EOL* matchedExpression { rightAssociative = true }

/* no EOL* before callArgumentsNoParenthesesManyStrict as first argument must be on same line so that function isn't
   interpreted as taking no arguments. */
noParenthesesExpression ::= (matchedExpressionDotIdentifier | identifierExpression) callArgumentsNoParenthesesManyStrict

//noParenthesesOneExpression ::= dotIdentifier

number ::= binaryWholeNumber |
           decimalNumber |
           hexadecimalWholeNumber |
           octalWholeNumber |
           unknownBaseWholeNumber
/*
 * Number Operations - Used in accessExpression
 */

numberAtOperation ::= AT_OPERATOR EOL* number
numberCaptureOperation ::= CAPTURE_OPERATOR EOL* number
numberUnaryOperation ::= (DUAL_OPERATOR | UNARY_OPERATOR) EOL* number

octalWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX OCTAL_WHOLE_NUMBER_BASE (INVALID_OCTAL_DIGITS | VALID_OCTAL_DIGITS)+ { pin=2 }

private quote ::= (charList | string)
sigil ::= interpolatedCharListSigil |
          interpolatedHeredocCharListSigil |
          interpolatedHeredocRegex |
          interpolatedHeredocSigil |
          interpolatedHeredocStringSigil |
          interpolatedHeredocWords |
          interpolatedRegex |
          interpolatedSigil |
          interpolatedStringSigil |
          literalCharListSigil |
          literalHeredocRegex |
          literalHeredocSigil |
          literalHeredocStringSigil |
          literalHeredocWords |
          literalRegex |
          literalSigil |
          literalStringSigil |
          literalWords
string ::= STRING_PROMOTER
           interpolatedStringBody
           STRING_TERMINATOR
stringHeredoc ::= STRING_HEREDOC_PROMOTER EOL
                  interpolatedStringBody
                  STRING_HEREDOC_TERMINATOR

unknownBaseWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX UNKNOWN_WHOLE_NUMBER_BASE INVALID_UNKNOWN_BASE_DIGITS+ { pin=2 }
