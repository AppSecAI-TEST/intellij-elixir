{
  parserClass="org.elixir_lang.parser.ElixirParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  /*
   * Ordered by rule being extended (extends(regex)=<rule-begin-extended)
   */

  extends("decimal(Float|WholeNUmber)")=decimalNumber
  extends("(.*Whole|decimal)Number")=number

  psiClassPrefix="Elixir"
  psiImplClassSuffix="Impl"
  psiPackage="org.elixir_lang.psi"
  psiImplPackage="org.elixir_lang.psi.impl"
  psiImplUtilClass="org.elixir_lang.psi.impl.ElixirPsiImplUtil"

  elementTypeHolderClass="org.elixir_lang.psi.ElixirTypes"
  elementTypeClass="org.elixir_lang.psi.ElixirElementType"
  tokenTypeClass="org.elixir_lang.psi.ElixirTokenType"

  tokens = [
    BASE_WHOLE_NUMBER_PREFIX = "0"
    BINARY_WHOLE_NUMBER_BASE = "b"
    CALL = ""
    CHAR_TOKENIZER = "?"
    CLOSING_BRACKET = "]"
    // TODO remove once CLOSING_PARENTHESIS is used in emptyParentheses rule
    CLOSING_PARENTHESIS = ")"
    COMMA = ","
    COMMENT = "regexp:#[^\r\n]*(\n|\r|\r\n)?"
    DECIMAL_MARK = "."
    DECIMAL_SEPARATOR = "_"
    DOT_OPERATOR = "."
    END = "end"
    FALSE = "false"
    FN = "fn"
    HEXADECIMAL_WHOLE_NUMBER_BASE = "x"
    IN_OPERATOR = "in"
    INVALID_BINARY_DIGITS = "regexp:[A-Za-z2-9]+"
    INVALID_UNKNOWN_BASE_DIGITS = "regexp:[A-Za-z0-9]+"
    NIL = "nil"
    OBSOLETE_BINARY_WHOLE_NUMBER_BASE = "B"
    OBSOLETE_HEXADECIMAL_WHOLE_NUMBER_BASE = "X"
    OCTAL_WHOLE_NUMBER_BASE = "o"
    OPENING_BRACKET = "["
    // TODO remove once OPENING_PARENTHESIS is used in emptyParentheses rule
    OPENING_PARENTHESIS = "("
    // TOO remove once SEMICOLON is used in endOfExpression rule
    SEMICOLON = ";"
    // TODO remove once containers are available for `{}` after alias for empty structs
    STRUCT_OPERATOR = "%"
    TRUE = "true"
    TYPE_OPERATOR = "::"
    UNKNOWN_WHOLE_NUMBER_BASE = "regexp:A-Zac-z"
    VALID_BINARY_DIGITS = "regexp:[01]+"
    VALID_HEXADECIMAL_DIGITS = "regexp:[A-Fa-f0-9]+"
  ]
}

// expressionList is optional to handle code-less file that contains only EOL between blank lines and order comment
// lines
private elixirFile ::= endOfExpression* (expressionList endOfExpression*)?

/*
 *
 *
 * Expression List
 *
 *
 */

private infixSemicolon ::= EOL* SEMICOLON EOL*
// Must have at least one EOL or SEMICOLON, but at most one SEMICOLON
endOfExpression ::= infixSemicolon | EOL { implements = "org.elixir_lang.psi.Unquoted" }
private expression ::= emptyParentheses |
                       noParenthesesManyArgumentsCall |
                       matchedExpression
private expressionList ::= expression (endOfExpression+ expression | adjacentExpression)*

/*
 *
 *
 * Function Calls
 *
 *
 */


/* The Elixir native lexer converts Strings, CharLists and keywords (false, nil, true) to ALIAS_TOKEN/IDENTIFIER as needed.
   Elixir.flex doesn't do that, so have to list those tokens/rules that would be converted to ALIAS_TOKEN/IDENTIFIER here */
matchedDotIdentifierOperand ::= IDENTIFIER |
                                atomKeyword |
                                binaryString |
                                listString
                                { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

left noParenthesesQualifiedIdentifier ::= dotInfixOperator matchedDotIdentifierOperand
                                          { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] }

/*
 *
 * No Parentheses
 *
 */

/*
 * Many Arguments
 */

private noParenthesesCommaExpression ::= matchedExpression (infixComma noParenthesesExpression)+
/* Have to prevent matchedExpression that is actually a keywordKey from being parsed as just a matchedExpression or
   callArgumentsNoParenthesesCommaExpression COMMA EOL* callArgumentsNoParenthesesKeywords will never match. */
noParenthesesExpression ::= emptyParentheses |
                            /* Must be before matchedExpression because noParenthesesExpression is
                               `matchedExpressionDotIdentifier callArgumentsNoParenthesesManyStrict` which is longer
                               than `matchedExpressionDotIdentifier` in matchedExpression. */
                            /* This will be marked as an error by
                               {@link org.elixir_lang.inspection.NoParenthesesManyStrict} */
                            noParenthesesManyStrictNoParenthesesExpression |
                            matchedExpression !KEYWORD_PAIR_COLON
                            { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
/* Special class for wrapping noParenthesesCall so that
   {@link: org.elixir_lang.inspection.NoParenthesesManyStrict} can just search for
   ElixirNoParenthesesManyStrictNoParenthesesExpression isn't of having to differentiate between valid and invalid
   ElixirNoParenthesesCall. */
noParenthesesManyStrictNoParenthesesExpression ::= noParenthesesManyArgumentsCall
/* Special class for wrapping rules so that
   {@link: org.elixir_lang.inspection.NoParenthesesStrict} can just search for
   ElixirNoParenthesesStrict instead of having to differentiate between valid and invalid
   rule classes. */
noParenthesesStrict ::= emptyParentheses |
                        OPENING_PARENTHESIS (
                                             noParenthesesKeywords |
                                             noParenthesesManyArguments
                                            ) CLOSING_PARENTHESIS

noParenthesesFirstPositional ::= matchedExpression
                                 { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
noParenthesesOnePositionalAndKeywordsArguments ::= noParenthesesFirstPositional infixComma noParenthesesKeywords
                                                   { implements = "org.elixir_lang.psi.QuotableArguments" methods = [quoteArguments] }
noParenthesesManyPositionalAndMaybeKeywordsArguments ::= noParenthesesCommaExpression (infixComma noParenthesesKeywords)?
                                                         { implements = "org.elixir_lang.psi.QuotableArguments" methods = [quoteArguments] }

/* 1. (positional, keywords)
   2. (positional, positional)
   3. (positional, positional, keywords) */
noParenthesesManyArguments ::= noParenthesesOnePositionalAndKeywordsArguments |
                               noParenthesesManyPositionalAndMaybeKeywordsArguments
                               { implements = "org.elixir_lang.psi.QuotableArguments" methods = [quoteArguments] }
private noParenthesesManyArgumentsStrict ::= noParenthesesManyArguments |
                                             noParenthesesStrict


/* Cannot use matchedDotExpression because need to ensure there is a qualifier and an identifier. Need to tweak the
   internals of matchedDotExpression so that at least one matchedDotOperation occurs by stripping the ( )? around the
   final two rules. */
// private because noParenthesesQualifiedIdentifier is a left rule so it will enclose everything and can handle quoting
private noParenthesesManyArgumentsQualifiedIdentifier ::= matchedDotLeftOperand matchedDotOperation* noParenthesesQualifiedIdentifier
/* Not the same as noParenthesesQualifiedIdentifier because with the '.' in qualification, things like strings, and true
   become valid identifiers. */
noParenthesesManyArgumentsUnqualifiedIdentifier ::= IDENTIFIER
                                                    { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L124-L125
noParenthesesManyArgumentsCall ::= (noParenthesesManyArgumentsQualifiedIdentifier | noParenthesesManyArgumentsUnqualifiedIdentifier)
                                   noParenthesesManyArgumentsStrict
                                   {
                                     implements = "org.elixir_lang.psi.Quotable"
                                     methods = [
                                       getArguments
                                       getIdentifier
                                       quote
                                     ]
                                   }

/*
 * 1+ Arguments
 */

noParenthesesKeywords ::= noParenthesesKeywordPair (infixComma noParenthesesKeywordPair)*
                          {
                            implements = "org.elixir_lang.psi.KeywordList"
                            methods = [
                              getKeywordPairList
                              quote
                            ]
                          }
noParenthesesKeywordPair ::= keywordKeyColonEOL noParenthesesExpression
                             {
                               implements = "org.elixir_lang.psi.KeywordPair"
                               methods = [
                                 getKeywordKey
                                 getKeywordValue
                                 quote
                               ]
                             }

/*
 * 0 Arguments
 */

left noParenthesesNoArgumentsCall ::= /* purposely empty as rule is only meant to enclose
                                         noParenthesesNoArgumentsQualifiedIdentifier, so it can use InfixOperation */
                                      { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
noParenthesesNoArgumentsUnqualifiedCallOrVariable ::= IDENTIFIER
                                                       { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

/*
 *
 *
 * Heredoc
 *
 *
 */

heredocLinePrefix ::= HEREDOC_LINE_WHITE_SPACE_TOKEN? { methods = [excessWhitespace] }
heredocPrefix ::= HEREDOC_PREFIX_WHITE_SPACE?

/*
 *
 * Quote Heredocs
 *
 */

/*
 * CharList Heredoc
 */

charListHeredoc ::= CHAR_LIST_HEREDOC_PROMOTER EOL
                    interpolatedCharListHeredocLine*
                    heredocPrefix CHAR_LIST_HEREDOC_TERMINATOR
                    {
                      implements = [
                        "org.elixir_lang.psi.Heredoc"
                        "org.elixir_lang.psi.InterpolatedCharList"
                        "org.elixir_lang.psi.InterpolatedCharListHeredocLined"
                        "org.elixir_lang.psi.Quote"
                      ]
                      methods = [
                        addEscapedCharacterCodePoints
                        addFragmentCodePoints
                        addHexadecimalEscapeSequenceCodePoints
                        getFragmentType
                        getHeredocLineList
                        quote
                        quoteBinary
                        quoteEmpty
                        quoteLiteral
                      ]
                      pin = 1
                    }
interpolatedCharListHeredocLine ::= heredocLinePrefix interpolatedCharListBody EOL
                                    {
                                      implements = [
                                        "org.elixir_lang.psi.HeredocLine"
                                      ]
                                      methods = [
                                        getBody
                                        quote
                                      ]
                                    }

/*
 * String Heredoc
 */

stringHeredoc ::= STRING_HEREDOC_PROMOTER EOL
                  interpolatedStringHeredocLine*
                  heredocPrefix STRING_HEREDOC_TERMINATOR
                  {
                    implements = [
                      "org.elixir_lang.psi.Heredoc"
                      "org.elixir_lang.psi.InterpolatedString"
                    ]
                    methods = [
                      addEscapedCharacterCodePoints
                      addFragmentCodePoints
                      addHexadecimalEscapeSequenceCodePoints
                      getFragmentType
                      getHeredocLineList
                      quote
                      quoteBinary
                      quoteEmpty
                      quoteLiteral
                    ]
                    pin = 1
                  }
interpolatedStringHeredocLine ::= heredocLinePrefix interpolatedStringBody EOL
                                  {
                                    implements = [
                                      "org.elixir_lang.psi.HeredocLine"
                                    ]
                                    methods = [
                                      getBody
                                      quote
                                    ]
                                  }

/*
 *
 * Interpolated Sigil Heredocs
 *
 */

sigilModifiers ::= SIGIL_MODIFIER* { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

interpolatedCharListSigilHeredoc ::= TILDE INTERPOLATING_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_HEREDOC_PROMOTER EOL
                                     interpolatedCharListHeredocLine*
                                     heredocPrefix CHAR_LIST_SIGIL_HEREDOC_TERMINATOR sigilModifiers
                                     {
                                       implements = [
                                         "org.elixir_lang.psi.CharListFragmented"
                                         "org.elixir_lang.psi.InterpolatedCharListHeredocLined"
                                         "org.elixir_lang.psi.SigilHeredoc"
                                       ]
                                       methods = [
                                         addEscapedCharacterCodePoints
                                         addFragmentCodePoints
                                         addHexadecimalEscapeSequenceCodePoints
                                         getFragmentType
                                         getHeredocLineList
                                         quote
                                         quoteBinary
                                         quoteEmpty
                                         quoteLiteral
                                         sigilName
                                       ]
                                       pin = 3
                                     }

interpolatedRegexHeredoc ::= TILDE INTERPOLATING_REGEX_SIGIL_NAME REGEX_HEREDOC_PROMOTER EOL
                             interpolatedRegexHeredocLine*
                             heredocPrefix REGEX_HEREDOC_TERMINATOR sigilModifiers
                             {
                               implements = [
                                 "org.elixir_lang.psi.RegexFragmented"
                                 "org.elixir_lang.psi.SigilHeredoc"
                               ]
                               methods = [
                                 addEscapedCharacterCodePoints
                                 addFragmentCodePoints
                                 addHexadecimalEscapeSequenceCodePoints
                                 getFragmentType
                                 getHeredocLineList
                                 quote
                                 quoteBinary
                                 quoteEmpty
                                 quoteLiteral
                                 sigilName
                               ]
                               pin = 3
                             }
interpolatedRegexHeredocLine ::= heredocLinePrefix interpolatedRegexBody EOL
                                 {
                                   implements = [
                                     "org.elixir_lang.psi.HeredocLine"
                                   ]
                                   methods = [
                                     getBody
                                     quote
                                   ]
                                 }
interpolatedRegexBody ::= (interpolation | REGEX_FRAGMENT | escapeSequence)*
                          { implements = "org.elixir_lang.psi.Body" }

interpolatedSigilHeredoc ::= TILDE INTERPOLATING_SIGIL_NAME SIGIL_HEREDOC_PROMOTER EOL
                             interpolatedSigilHeredocLine*
                             heredocPrefix SIGIL_HEREDOC_TERMINATOR sigilModifiers
                             {
                               implements = [
                                 "org.elixir_lang.psi.SigilFragmented"
                                 "org.elixir_lang.psi.SigilHeredoc"
                               ]
                               methods = [
                                 addEscapedCharacterCodePoints
                                 addFragmentCodePoints
                                 addHexadecimalEscapeSequenceCodePoints
                                 getFragmentType
                                 getHeredocLineList
                                 quote
                                 quoteBinary
                                 quoteEmpty
                                 quoteLiteral
                                 sigilName
                               ]
                               pin = 3
                             }
interpolatedSigilHeredocLine ::= heredocLinePrefix interpolatedSigilBody EOL
                                 {
                                   implements = [
                                     "org.elixir_lang.psi.HeredocLine"
                                   ]
                                   methods = [
                                     getBody
                                     quote
                                   ]
                                 }
interpolatedSigilBody ::= (interpolation | SIGIL_FRAGMENT | escapeSequence)*
                          { implements = "org.elixir_lang.psi.Body" }

interpolatedStringSigilHeredoc ::= TILDE INTERPOLATING_STRING_SIGIL_NAME STRING_SIGIL_HEREDOC_PROMOTER EOL
                                     interpolatedStringHeredocLine*
                                     heredocPrefix STRING_SIGIL_HEREDOC_TERMINATOR sigilModifiers
                                     {
                                       implements = [
                                         "org.elixir_lang.psi.StringFragmented"
                                         "org.elixir_lang.psi.InterpolatedStringHeredocLined"
                                         "org.elixir_lang.psi.SigilHeredoc"
                                       ]
                                       methods = [
                                         addEscapedCharacterCodePoints
                                         addFragmentCodePoints
                                         addHexadecimalEscapeSequenceCodePoints
                                         getFragmentType
                                         getHeredocLineList
                                         quote
                                         quoteBinary
                                         quoteEmpty
                                         quoteLiteral
                                         sigilName
                                       ]
                                       pin = 3
                                     }

interpolatedWordsHeredoc ::= TILDE INTERPOLATING_WORDS_SIGIL_NAME WORDS_HEREDOC_PROMOTER EOL
                             interpolatedWordsHeredocLine*
                             heredocPrefix WORDS_HEREDOC_TERMINATOR sigilModifiers
                             {
                               implements = [
                                 "org.elixir_lang.psi.WordsFragmented"
                                 "org.elixir_lang.psi.SigilHeredoc"
                               ]
                               methods = [
                                 addEscapedCharacterCodePoints
                                 addFragmentCodePoints
                                 addHexadecimalEscapeSequenceCodePoints
                                 getFragmentType
                                 getHeredocLineList
                                 quote
                                 quoteBinary
                                 quoteEmpty
                                 quoteLiteral
                                 sigilName
                               ]
                               pin = 3
                             }
interpolatedWordsHeredocLine ::= heredocLinePrefix interpolatedWordsBody EOL
                                 {
                                   implements = [
                                     "org.elixir_lang.psi.HeredocLine"
                                   ]
                                   methods = [
                                     getBody
                                     quote
                                   ]
                                 }
interpolatedWordsBody ::= (interpolation | WORDS_FRAGMENT | escapeSequence)*
                          { implements = "org.elixir_lang.psi.Body" }

/*
 * Literal Sigil Heredocs
 */

literalCharListSigilHeredoc ::= TILDE LITERAL_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_HEREDOC_PROMOTER EOL
                                literalCharListHeredocLine*
                                heredocPrefix CHAR_LIST_SIGIL_HEREDOC_TERMINATOR sigilModifiers
                                {
                                  implements = [
                                    "org.elixir_lang.psi.CharListFragmented"
                                    "org.elixir_lang.psi.SigilHeredoc"
                                  ]
                                  methods = [
                                    addEscapedCharacterCodePoints
                                    addFragmentCodePoints
                                    addHexadecimalEscapeSequenceCodePoints
                                    getFragmentType
                                    getHeredocLineList
                                    quote
                                    quoteBinary
                                    quoteEmpty
                                    quoteLiteral
                                    sigilName
                                  ]
                                  pin = 3
                                }
literalCharListHeredocLine ::= heredocLinePrefix literalCharListBody EOL
                               {
                                 implements = [
                                   "org.elixir_lang.psi.HeredocLine"
                                 ]
                                 methods = [
                                   getBody
                                   quote
                                 ]
                               }
literalCharListBody ::= CHAR_LIST_FRAGMENT*
                        { implements = "org.elixir_lang.psi.Body" }

literalRegexHeredoc ::= TILDE LITERAL_REGEX_SIGIL_NAME REGEX_HEREDOC_PROMOTER EOL
                        literalRegexHeredocLine*
                        heredocPrefix REGEX_HEREDOC_TERMINATOR sigilModifiers
                        {
                          implements = [
                            "org.elixir_lang.psi.RegexFragmented"
                            "org.elixir_lang.psi.SigilHeredoc"
                          ]
                          methods = [
                            addEscapedCharacterCodePoints
                            addFragmentCodePoints
                            addHexadecimalEscapeSequenceCodePoints
                            getFragmentType
                            getHeredocLineList
                            quote
                            quoteBinary
                            quoteEmpty
                            quoteLiteral
                            sigilName
                          ]
                          pin = 3
                        }
literalRegexHeredocLine ::= heredocLinePrefix literalRegexBody EOL
                            {
                              implements = [
                                "org.elixir_lang.psi.HeredocLine"
                              ]
                              methods = [
                                getBody
                                quote
                              ]
                            }
literalRegexBody ::= REGEX_FRAGMENT*
                     { implements = "org.elixir_lang.psi.Body" }

literalSigilHeredoc ::= TILDE LITERAL_SIGIL_NAME SIGIL_HEREDOC_PROMOTER EOL
                        literalSigilHeredocLine*
                        heredocPrefix SIGIL_HEREDOC_TERMINATOR sigilModifiers
                        {
                          implements = [
                            "org.elixir_lang.psi.SigilFragmented"
                            "org.elixir_lang.psi.SigilHeredoc"
                          ]
                          methods = [
                            addEscapedCharacterCodePoints
                            addFragmentCodePoints
                            addHexadecimalEscapeSequenceCodePoints
                            getFragmentType
                            getHeredocLineList
                            quote
                            quoteBinary
                            quoteEmpty
                            quoteLiteral
                            sigilName
                          ]
                          pin = 3
                        }
literalSigilHeredocLine ::= heredocLinePrefix literalSigilBody EOL
                            {
                              implements = [
                                "org.elixir_lang.psi.HeredocLine"
                              ]
                              methods = [
                                getBody
                                quote
                              ]
                            }
literalSigilBody ::= SIGIL_FRAGMENT*
                     { implements = "org.elixir_lang.psi.Body" }
                     
literalStringSigilHeredoc ::= TILDE LITERAL_STRING_SIGIL_NAME STRING_SIGIL_HEREDOC_PROMOTER EOL
                              literalStringHeredocLine*
                              heredocPrefix STRING_SIGIL_HEREDOC_TERMINATOR sigilModifiers
                              {
                                implements = [
                                  "org.elixir_lang.psi.StringFragmented"
                                  "org.elixir_lang.psi.SigilHeredoc"
                                ]
                                methods = [
                                  addEscapedCharacterCodePoints
                                  addFragmentCodePoints
                                  addHexadecimalEscapeSequenceCodePoints
                                  getFragmentType
                                  getHeredocLineList
                                  quote
                                  quoteBinary
                                  quoteEmpty
                                  quoteLiteral
                                  sigilName
                                ]
                                pin = 3
                              }
literalStringHeredocLine ::= heredocLinePrefix literalStringBody EOL
                             {
                               implements = [
                                 "org.elixir_lang.psi.HeredocLine"
                               ]
                               methods = [
                                 getBody
                                 quote
                               ]
                             }
literalStringBody ::= STRING_FRAGMENT*
                      { implements = "org.elixir_lang.psi.Body" }
                      
literalWordsHeredoc ::= TILDE LITERAL_WORDS_SIGIL_NAME WORDS_HEREDOC_PROMOTER EOL
                        literalWordsHeredocLine*
                        heredocPrefix WORDS_HEREDOC_TERMINATOR sigilModifiers
                        {
                          implements = [
                            "org.elixir_lang.psi.WordsFragmented"
                            "org.elixir_lang.psi.SigilHeredoc"
                          ]
                          methods = [
                            addEscapedCharacterCodePoints
                            addFragmentCodePoints
                            addHexadecimalEscapeSequenceCodePoints
                            getFragmentType
                            getHeredocLineList
                            quote
                            quoteBinary
                            quoteEmpty
                            quoteLiteral
                            sigilName
                          ]
                          pin = 3
                        }
literalWordsHeredocLine ::= heredocLinePrefix literalWordsBody EOL
                            {
                              implements = [
                                "org.elixir_lang.psi.HeredocLine"
                              ]
                              methods = [
                                getBody
                                quote
                              ]
                            }
literalWordsBody ::= WORDS_FRAGMENT*
                     { implements = "org.elixir_lang.psi.Body" }

/*
 *
 *
 * Lines (as opposed to Heredocs)
 *
 *
 */

/*
 *
 * Quote Lines
 *
 */


interpolatedCharListBody ::= (interpolation | CHAR_LIST_FRAGMENT | escapeSequence)*
                             { implements =  "org.elixir_lang.psi.Body" }
charListLine ::= CHAR_LIST_PROMOTER interpolatedCharListBody CHAR_LIST_TERMINATOR
                 {
                   implements = [
                     "org.elixir_lang.psi.Atomable"
                     "org.elixir_lang.psi.InterpolatedCharList"
                     "org.elixir_lang.psi.Quotable"
                   ]
                   methods = [
                     addEscapedCharacterCodePoints
                     addFragmentCodePoints
                     addHexadecimalEscapeSequenceCodePoints
                     getFragmentType
                     quote
                     quoteAsAtom
                     quoteBinary
                     quoteEmpty
                     quoteLiteral
                   ]
                 }

interpolatedStringBody ::=  (interpolation | STRING_FRAGMENT | escapeSequence)*
                            { implements = "org.elixir_lang.psi.Body" }
stringLine ::= STRING_PROMOTER
               interpolatedStringBody
               STRING_TERMINATOR
               {
                 implements = [
                   "org.elixir_lang.psi.Atomable"
                   "org.elixir_lang.psi.InterpolatedString"
                   "org.elixir_lang.psi.Quotable"
                 ]
                 methods = [
                   addEscapedCharacterCodePoints
                   addFragmentCodePoints
                   addHexadecimalEscapeSequenceCodePoints
                   getFragmentType
                   quote
                   quoteAsAtom
                   quoteBinary
                   quoteEmpty
                   quoteLiteral
                 ]
               }

/*
 *
 * Sigil Lines
 *
 */

/*
 * Interpolated Sigil Lines
 */

interpolatedCharListSigilLine ::= TILDE INTERPOLATING_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_PROMOTER interpolatedCharListBody CHAR_LIST_SIGIL_TERMINATOR sigilModifiers
                                  {
                                    implements = [
                                      "org.elixir_lang.psi.CharListFragmented"
                                      "org.elixir_lang.psi.SigilLine"
                                    ]
                                    methods = [
                                      addEscapedCharacterCodePoints
                                      addFragmentCodePoints
                                      addHexadecimalEscapeSequenceCodePoints
                                      getBody
                                      getFragmentType
                                      quote
                                      quoteBinary
                                      quoteEmpty
                                      quoteLiteral
                                      sigilName
                                    ]
                                  }

interpolatedRegexLine ::= TILDE INTERPOLATING_REGEX_SIGIL_NAME REGEX_PROMOTER interpolatedRegexBody REGEX_TERMINATOR sigilModifiers
                          {
                            implements = [
                              "org.elixir_lang.psi.RegexFragmented"
                              "org.elixir_lang.psi.SigilLine"
                            ]
                            methods = [
                              addEscapedCharacterCodePoints
                              addFragmentCodePoints
                              addHexadecimalEscapeSequenceCodePoints
                              getBody
                              getFragmentType
                              quote
                              quoteBinary
                              quoteEmpty
                              quoteLiteral
                              sigilName
                            ]
                          }

interpolatedSigilLine ::= TILDE INTERPOLATING_SIGIL_NAME SIGIL_PROMOTER interpolatedSigilBody SIGIL_TERMINATOR sigilModifiers
                          {
                            implements = [
                              "org.elixir_lang.psi.SigilFragmented"
                              "org.elixir_lang.psi.SigilLine"
                            ]
                            methods = [
                              addEscapedCharacterCodePoints
                              addFragmentCodePoints
                              addHexadecimalEscapeSequenceCodePoints
                              getBody
                              getFragmentType
                              quote
                              quoteBinary
                              quoteEmpty
                              quoteLiteral
                              sigilName
                            ]
                          }

interpolatedStringSigilLine ::= TILDE INTERPOLATING_STRING_SIGIL_NAME STRING_SIGIL_PROMOTER interpolatedStringBody STRING_SIGIL_TERMINATOR sigilModifiers
                                {
                                  implements = [
                                    "org.elixir_lang.psi.StringFragmented"
                                    "org.elixir_lang.psi.SigilLine"
                                  ]
                                  methods = [
                                    addEscapedCharacterCodePoints
                                    addFragmentCodePoints
                                    addHexadecimalEscapeSequenceCodePoints
                                    getBody
                                    getFragmentType
                                    quote
                                    quoteBinary
                                    quoteEmpty
                                    quoteLiteral
                                    sigilName
                                  ]
                                }

interpolatedWordsLine ::= TILDE INTERPOLATING_WORDS_SIGIL_NAME WORDS_PROMOTER interpolatedWordsBody WORDS_TERMINATOR sigilModifiers
                          {
                            implements = [
                              "org.elixir_lang.psi.WordsFragmented"
                              "org.elixir_lang.psi.SigilLine"
                            ]
                            methods = [
                              addEscapedCharacterCodePoints
                              addFragmentCodePoints
                              addHexadecimalEscapeSequenceCodePoints
                              getBody
                              getFragmentType
                              quote
                              quoteBinary
                              quoteEmpty
                              quoteLiteral
                              sigilName
                            ]
                          }
/*
 * Literal Sigils
 */

literalCharListSigilLine ::= TILDE LITERAL_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_PROMOTER literalCharListBody CHAR_LIST_SIGIL_TERMINATOR sigilModifiers
                             {
                               implements = [
                                 "org.elixir_lang.psi.CharListFragmented"
                                 "org.elixir_lang.psi.SigilLine"
                               ]
                               methods = [
                                 addEscapedCharacterCodePoints
                                 addFragmentCodePoints
                                 addHexadecimalEscapeSequenceCodePoints
                                 getBody
                                 getFragmentType
                                 quote
                                 quoteBinary
                                 quoteEmpty
                                 quoteLiteral
                                 sigilName
                               ]
                             }

literalRegexLine ::= TILDE LITERAL_REGEX_SIGIL_NAME REGEX_PROMOTER literalRegexBody REGEX_TERMINATOR sigilModifiers
                     {
                       implements = [
                         "org.elixir_lang.psi.RegexFragmented"
                         "org.elixir_lang.psi.SigilLine"
                       ]
                       methods = [
                         addEscapedCharacterCodePoints
                         addFragmentCodePoints
                         addHexadecimalEscapeSequenceCodePoints
                         getBody
                         getFragmentType
                         quote
                         quoteBinary
                         quoteEmpty
                         quoteLiteral
                         sigilName
                       ]
                     }

literalSigilLine ::= TILDE LITERAL_SIGIL_NAME SIGIL_PROMOTER literalSigilBody SIGIL_TERMINATOR sigilModifiers
                     {
                       implements = [
                         "org.elixir_lang.psi.SigilFragmented"
                         "org.elixir_lang.psi.SigilLine"
                       ]
                       methods = [
                         addEscapedCharacterCodePoints
                         addFragmentCodePoints
                         addHexadecimalEscapeSequenceCodePoints
                         getBody
                         getFragmentType
                         quote
                         quoteBinary
                         quoteEmpty
                         quoteLiteral
                         sigilName
                       ]
                     }

literalStringSigilLine ::= TILDE LITERAL_STRING_SIGIL_NAME STRING_SIGIL_PROMOTER literalStringBody STRING_SIGIL_TERMINATOR sigilModifiers
                           {
                             implements = [
                               "org.elixir_lang.psi.StringFragmented"
                               "org.elixir_lang.psi.SigilLine"
                             ]
                             methods = [
                               addEscapedCharacterCodePoints
                               addFragmentCodePoints
                               addHexadecimalEscapeSequenceCodePoints
                               getBody
                               getFragmentType
                               quote
                               quoteBinary
                               quoteEmpty
                               quoteLiteral
                               sigilName
                             ]
                           }

literalWordsLine ::=  TILDE LITERAL_WORDS_SIGIL_NAME WORDS_PROMOTER literalWordsBody WORDS_TERMINATOR sigilModifiers
                      {
                        implements = [
                          "org.elixir_lang.psi.WordsFragmented"
                          "org.elixir_lang.psi.SigilLine"
                        ]
                        methods = [
                          addEscapedCharacterCodePoints
                          addFragmentCodePoints
                          addHexadecimalEscapeSequenceCodePoints
                          getBody
                          getFragmentType
                          quote
                          quoteBinary
                          quoteEmpty
                          quoteLiteral
                          sigilName
                        ]
                      }

/*
 *
 *
 * Matched Expressions - ordered by outer-most (lowest precedence) to inner-most (highest precedence)
 *
 * See ELIXIR_BNF_DESIGN.md for exanplanation of the naming and nesting pattern used in the matchedExpression rules.
 *
 *
 */

private matchedExpression ::= matchedNonNumericCaptureExpression

// non-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L50)
capturePrefixOperator ::= CAPTURE_OPERATOR EOL*
                          {
                            implements = "org.elixir_lang.psi.Operator"
                            methods = [
                              operatorTokenSet
                              quote
                            ]
                            name = "&"
                          }
private nonNumericCapturePrefixOperator ::= capturePrefixOperator !numeric

private matchedNonNumericCaptureExpression ::= matchedNonNumericCaptureRightExpression |
                                               matchedMultiplicationExpression

private matchedNonNumericCaptureRightExpression ::= matchedNonNumericCaptureRightOperation
private matchedNonNumericCaptureRightOperand ::= noParenthesesManyArgumentsCall | matchedNonNumericCaptureLeftOperand
matchedNonNumericCaptureRightOperation ::= nonNumericCapturePrefixOperator matchedNonNumericCaptureRightOperand
                                           { implements = "org.elixir_lang.psi.PrefixOperation" methods = [quote] }

private matchedNonNumericCaptureLeftExpression ::= matchedNonNumericCaptureLeftOperation | matchedNonNumericCaptureLeftOperand
private matchedNonNumericCaptureLeftOperand ::= matchedNonNumericCaptureLeftOperation | matchedMultiplicationLeftExpression
matchedNonNumericCaptureLeftOperation ::= nonNumericCapturePrefixOperator matchedNonNumericCaptureLeftOperand
                                          { implements = "org.elixir_lang.psi.PrefixOperation" methods = [quote] }

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L65)
multiplicationInfixOperator ::= EOL* MULTIPLICATION_OPERATOR EOL*
                                {
                                  implements = "org.elixir_lang.psi.Operator"
                                  methods = [
                                    operatorTokenSet
                                    quote
                                  ]
                                  name = "*, /"
                                }
private matchedMultiplicationExpression ::= matchedMultiplicationRightExpression |
                                            matchedHatExpression

private matchedMultiplicationRightExpression ::= matchedMultiplicationLeftOperand matchedMultiplicationRightOperation+
private matchedMultiplicationRightOperand ::= noParenthesesManyArgumentsCall | matchedMultiplicationLeftOperand
left matchedMultiplicationRightOperation ::= multiplicationInfixOperator matchedMultiplicationRightOperand
                                             { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] }

private matchedMultiplicationLeftExpression ::= matchedMultiplicationLeftOperand matchedMultiplicationLeftOperation*
private matchedMultiplicationLeftOperand ::= matchedNonNumericCaptureLeftOperation | matchedHatLeftExpression
left matchedMultiplicationLeftOperation ::= multiplicationInfixOperator matchedMultiplicationLeftOperand
                                            { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] }

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L66)
hatInfixOperator ::= EOL* HAT_OPERATOR EOL*
                     {
                       implements = "org.elixir_lang.psi.Operator"
                       methods = [
                         operatorTokenSet
                         quote
                       ]
                       name = "^^^"
                     }
private matchedHatExpression ::= matchedHatRightExpression |
                                 matchedNonNumericUnaryExpression

private matchedHatRightExpression ::= matchedHatLeftOperand matchedHatRightOperation+
private matchedHatRightOperand ::= noParenthesesManyArgumentsCall | matchedHatLeftOperand
left matchedHatRightOperation ::= hatInfixOperator matchedHatRightOperand
                                  { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] }

private matchedHatLeftExpression ::= matchedHatLeftOperand matchedHatLeftOperation*
private matchedHatLeftOperand ::= matchedNonNumericCaptureLeftOperation | matchedNonNumericUnaryLeftExpression
left matchedHatLeftOperation ::= hatInfixOperator matchedHatLeftOperand
                                 { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] }

// non-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L67)
unaryPrefixOperator ::= (DUAL_OPERATOR | UNARY_OPERATOR) EOL*
                        {
                          implements = "org.elixir_lang.psi.Operator"
                          methods = [
                            operatorTokenSet
                            quote
                          ]
                          name = "+, -, !, ^, not, ~~~"
                        }
private nonNumericUnaryPrefixOperator ::= unaryPrefixOperator !numeric

private matchedNonNumericUnaryExpression ::= matchedNonNumericUnaryRightExpression |
                                             matchedDotExpression

private matchedNonNumericUnaryRightExpression ::= matchedNonNumericUnaryRightOperation
private matchedNonNumericUnaryRightOperand ::= noParenthesesManyArgumentsCall | matchedNonNumericUnaryLeftOperand
matchedNonNumericUnaryRightOperation ::= nonNumericUnaryPrefixOperator matchedNonNumericUnaryRightOperand
                                         { implements = "org.elixir_lang.psi.PrefixOperation" methods = [quote] }

private matchedNonNumericUnaryLeftExpression ::= matchedNonNumericUnaryLeftOperation | matchedNonNumericUnaryLeftOperand
private matchedNonNumericUnaryLeftOperand ::= matchedNonNumericCaptureLeftOperation | matchedNonNumericUnaryLeftOperation | matchedDotLeftExpression
matchedNonNumericUnaryLeftOperation ::= nonNumericUnaryPrefixOperator matchedNonNumericUnaryLeftOperand
                                        { implements = "org.elixir_lang.psi.PrefixOperation" methods = [quote] }

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L69)
dotInfixOperator ::= EOL* DOT_OPERATOR EOL*
                     {
                       implements = "org.elixir_lang.psi.Operator"
                       name = "."
                       methods = [
                         operatorTokenSet
                         quote
                       ]
                     }
private matchedDotExpression ::= matchedDotRightExpression |
                                 matchedNonNumericAtExpression

private matchedDotRightExpression ::= matchedDotLeftOperand matchedDotRightOperation* matchedDotRightMostOperation
private matchedDotRightOperand ::= (
                                    alias |
                                    IDENTIFIER |
                                    FALSE |
                                    NIL |
                                    TRUE |
                                    binaryString |
                                    listString
                                   ) &dotInfixOperator
left matchedDotRightOperation ::= dotInfixOperator matchedDotRightOperand
                                  { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] }

private matchedDotRightMostOperation ::= noParenthesesQualifiedIdentifier noParenthesesNoArgumentsCall | qualifiedAlias
left qualifiedAlias ::= dotInfixOperator alias
                        { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

private matchedDotLeftExpression ::= matchedDotLeftOperand matchedDotLeftOperation*
private matchedDotLeftOperand ::= matchedNonNumericAtLeftExpression
left matchedDotLeftOperation ::= dotInfixOperator matchedDotLeftOperand
                                 { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] }

// non-associative (https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L70)
atPrefixOperator ::= AT_OPERATOR EOL*
                     {
                       implements = "org.elixir_lang.psi.Operator"
                       methods = [
                         operatorTokenSet
                         quote
                       ]
                       name = "@"
                     }
private nonNumericAtPrefixOperator ::= atPrefixOperator !numeric

private matchedNonNumericAtExpression ::= matchedNonNumericAtRightExpression |
                                          accessExpression

private matchedNonNumericAtRightExpression ::= matchedNonNumericAtRightOperation
private matchedNonNumericAtRightOperand ::= noParenthesesManyArgumentsCall | matchedNonNumericAtLeftOperand
matchedNonNumericAtRightOperation ::= nonNumericAtPrefixOperator matchedNonNumericAtRightOperand
                                      { implements = "org.elixir_lang.psi.PrefixOperation" methods = [quote] }

private matchedNonNumericAtLeftExpression ::= matchedNonNumericAtLeftOperation | matchedNonNumericAtLeftOperand
private matchedNonNumericAtLeftOperand ::= matchedNonNumericCaptureLeftOperation | matchedNonNumericUnaryLeftOperation | noParenthesesNoArgumentsUnqualifiedCallOrVariable | accessExpression
matchedNonNumericAtLeftOperation ::= nonNumericAtPrefixOperator matchedNonNumericAtLeftOperand
                                     { implements = "org.elixir_lang.psi.PrefixOperation" methods = [quote] }

atNumericOperation ::= atPrefixOperator numeric
                       { implements = "org.elixir_lang.psi.PrefixOperation" methods = [quote] }
captureNumericOperation ::= capturePrefixOperator numeric
                            { implements = "org.elixir_lang.psi.PrefixOperation" methods = [quote] }
unaryNumericOperation ::= unaryPrefixOperator numeric
                          { implements = "org.elixir_lang.psi.PrefixOperation" methods = [quote] }

emptyBlock ::= OPENING_PARENTHESIS infixSemicolon CLOSING_PARENTHESIS
               { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

private accessExpression ::= atNumericOperation |
                             captureNumericOperation |
                             unaryNumericOperation |
                             emptyBlock |
                             numeric |
                             list |
                             binaryString |
                             listString |
                             sigil |
                             atomKeyword |
                             atom |
                             alias

// keywords that map to atoms
atomKeyword ::= FALSE | NIL | TRUE
                { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

alias ::= ALIAS_TOKEN
          { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

/*
 *
 *
 * Whole Numbers
 *
 *
 *
 */

decimalDigits ::= INVALID_DECIMAL_DIGITS | VALID_DECIMAL_DIGITS
                  { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
decimalWholeNumber ::= decimalDigits (DECIMAL_SEPARATOR? decimalDigits)*
                        {
                          implements = "org.elixir_lang.psi.WholeNumber"
                          methods = [
                            base
                            digitsList
                            quote
                          ]
                        }

/*
 *
 * Base (Non-Decimal) Whole Numbers
 *
 */

/*
 * Binary (2)
 */

binaryDigits ::= INVALID_BINARY_DIGITS | VALID_BINARY_DIGITS
                 { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
binaryWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX (BINARY_WHOLE_NUMBER_BASE | OBSOLETE_BINARY_WHOLE_NUMBER_BASE) binaryDigits+
                     {
                       implements = "org.elixir_lang.psi.WholeNumber"
                       methods = [
                         base
                         digitsList
                         quote
                       ]
                       pin = 2
                     }

/*
 * Hexadecimal (16)
 */

hexadecimalDigits ::= INVALID_HEXADECIMAL_DIGITS | VALID_HEXADECIMAL_DIGITS
                      { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
hexadecimalWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX (HEXADECIMAL_WHOLE_NUMBER_BASE | OBSOLETE_HEXADECIMAL_WHOLE_NUMBER_BASE) hexadecimalDigits+
                           {
                             implements = "org.elixir_lang.psi.WholeNumber"
                             methods = [
                               base
                               digitsList
                               quote
                             ]
                             pin = 2
                           }

/*
 * Octal (8)
 */

octalDigits ::= INVALID_OCTAL_DIGITS | VALID_OCTAL_DIGITS
                { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
octalWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX OCTAL_WHOLE_NUMBER_BASE octalDigits+
                     {
                       implements = "org.elixir_lang.psi.WholeNumber"
                       methods = [
                         base
                         digitsList
                         quote
                       ]
                       pin = 2
                     }

/*
 * Unknown (1-36)
 */

unknownBaseDigits ::= INVALID_UNKNOWN_BASE_DIGITS
                      { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
unknownBaseWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX UNKNOWN_WHOLE_NUMBER_BASE unknownBaseDigits+
                           {
                             implements = "org.elixir_lang.psi.WholeNumber"
                             methods = [
                               base
                               digitsList
                               quote
                             ]
                             pin=2
                           }

/*
 *
 *
 * In alphabetical order
 *
 *
 */

// an expression in an expressionList that is NOT preceded by endOfExpression(s)
adjacentExpression ::= expression
atom ::= COLON (ATOM_FRAGMENT | quote)
         { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

private binaryString ::= stringLine | stringHeredoc
private infixComma ::= COMMA EOL*

charToken ::= CHAR_TOKENIZER (CHAR_LIST_FRAGMENT | escapeSequence)
              { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

private containerExpression ::= emptyParentheses

decimalFloat ::= decimalFloatIntegral DECIMAL_MARK decimalFloatFractional (EXPONENT_MARK decimalFloatExponent)?
                 { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
decimalFloatExponent ::= decimalFloatExponentSign decimalWholeNumber
decimalFloatExponentSign ::= DUAL_OPERATOR?
decimalFloatFractional ::= decimalWholeNumber
decimalFloatIntegral ::= decimalWholeNumber

// decimalFloat starts with decimalWholeNumber, so decimalFloat needs to be first
decimalNumber ::= decimalFloat |
                  decimalWholeNumber
private escapeSequence ::= hexadecimalEscapeSequence |
                           escapedEOL |
                           /* Must be last so that ESCAPE ('\') can be pinned in escapedCharacter without excluding
                              ("\x") in hexadecimalEscapeSequence  */
                           escapedCharacter
hexadecimalEscapeSequence ::= ESCAPE HEXADECIMAL_WHOLE_NUMBER_BASE (openHexadecimalEscapeSequence | enclosedHexadecimalEscapeSequence) { methods = [codePoint] pin = 2 }
enclosedHexadecimalEscapeSequence ::= OPENING_CURLY VALID_HEXADECIMAL_DIGITS CLOSING_CURLY
                                      { implements = "org.elixir_lang.psi.EscapedHexadecimalDigits" methods = [codePoint] pin = 1 }
openHexadecimalEscapeSequence ::= VALID_HEXADECIMAL_DIGITS
                                  { implements = "org.elixir_lang.psi.EscapedHexadecimalDigits" methods = [codePoint] }
escapedCharacter ::= ESCAPE ESCAPED_CHARACTER_TOKEN
                     { implements = "org.elixir_lang.psi.EscapeSequence" methods = [codePoint] pin = 1 }
escapedEOL ::= ESCAPE EOL
emptyParentheses ::= OPENING_PARENTHESIS EOL* CLOSING_PARENTHESIS
                     { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
interpolation ::= INTERPOLATION_START elixirFile INTERPOLATION_END
                  { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
keywordKey ::= ALIAS_TOKEN |
               AND_OPERATOR |
               ARROW_OPERATOR |
               ASSOCIATION_OPERATOR |
               AT_OPERATOR |
               BIT_STRING_OPERATOR |
               CAPTURE_OPERATOR |
               COMPARISON_OPERATOR |
               DUAL_OPERATOR |
               HAT_OPERATOR |
               IDENTIFIER |
               IN_MATCH_OPERATOR |
               IN_OPERATOR |
               MAP_OPERATOR |
               MATCH_OPERATOR |
               MULTIPLICATION_OPERATOR |
               OR_OPERATOR |
               PIPE_OPERATOR |
               RELATIONAL_OPERATOR |
               STAB_OPERATOR |
               STRUCT_OPERATOR |
               TUPLE_OPERATOR |
               TWO_OPERATOR |
               UNARY_OPERATOR |
               WHEN_OPERATOR |
               quote
               { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
private keywordKeyColonEOL ::= keywordKey KEYWORD_PAIR_COLON EOL*
listKeywordPair ::=  keywordKeyColonEOL keywordValue
                     {
                       implements = "org.elixir_lang.psi.KeywordPair"
                       methods = [
                         getKeywordKey
                         getKeywordValue
                         quote
                       ]
                     }
keywordValue ::= containerExpression
                 { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
list ::= OPENING_BRACKET EOL* (listKeywordPair (infixComma listKeywordPair)* COMMA?)? CLOSING_BRACKET
         { implements = "org.elixir_lang.psi.KeywordList" methods = [getKeywordPairList quote] }
private listString ::= charListLine | charListHeredoc

/* elixir_tokenizer.erl converts CHAR_TOKEN_TOKENs to their number representation, so `number` in elixir_parser.yrl matches
   Elixir.flex's NUMBER and CHAR_TOKEN_TOKEN. */
private numeric ::= charToken | number

//noParenthesesOneExpression ::= dotIdentifier

number ::= binaryWholeNumber |
           decimalNumber |
           hexadecimalWholeNumber |
           octalWholeNumber |
           unknownBaseWholeNumber
/*
 * Number Operations - Used in accessExpression
 */

private quote ::= (charListLine | stringLine)
private sigil ::= interpolatedCharListSigilLine |
                  interpolatedCharListSigilHeredoc |
                  interpolatedRegexHeredoc |
                  interpolatedSigilHeredoc |
                  interpolatedStringSigilHeredoc |
                  interpolatedWordsHeredoc |
                  interpolatedWordsLine |
                  interpolatedRegexLine |
                  interpolatedSigilLine |
                  interpolatedStringSigilLine |
                  literalCharListSigilLine |
                  literalCharListSigilHeredoc |
                  literalRegexHeredoc |
                  literalSigilHeredoc |
                  literalStringSigilHeredoc |
                  literalWordsHeredoc |
                  literalRegexLine |
                  literalSigilLine |
                  literalStringSigilLine |
                  literalWordsLine
