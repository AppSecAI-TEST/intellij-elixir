{
  parserClass="org.elixir_lang.parser.ElixirParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  /*
   * Ordered by rule being extended (extends(regex)=<rule-begin-extended)
   */

  extends("decimal(Float|WholeNUmber)")=decimalNumber
  extends("(.*Whole|decimal)Number")=number

  psiClassPrefix="Elixir"
  psiImplClassSuffix="Impl"
  psiPackage="org.elixir_lang.psi"
  psiImplPackage="org.elixir_lang.psi.impl"
  psiImplUtilClass="org.elixir_lang.psi.impl.ElixirPsiImplUtil"

  elementTypeHolderClass="org.elixir_lang.psi.ElixirTypes"
  elementTypeClass="org.elixir_lang.psi.ElixirElementType"
  tokenTypeClass="org.elixir_lang.psi.ElixirTokenType"

  tokens = [
    BASE_WHOLE_NUMBER_PREFIX = "0"
    BINARY_WHOLE_NUMBER_BASE = "b"
    CALL = ""
    CLOSING_BRACKET = "]"
    // TODO remove once CLOSING_PARENTHESIS is used in emptyParentheses rule
    CLOSING_PARENTHESIS = ")"
    COMMA = ","
    COMMENT = "regexp:#[^\r\n]*(\n|\r|\r\n)?"
    DECIMAL_MARK = "."
    DECIMAL_SEPARATOR = "_"
    DOT_OPERATOR = "."
    END = "end"
    FALSE = "false"
    FN = "fn"
    HEXADECIMAL_WHOLE_NUMBER_BASE = "x"
    IN_OPERATOR = "in"
    INVALID_BINARY_DIGITS = "regexp:[A-Za-z2-9]+"
    INVALID_UNKNOWN_BASE_DIGITS = "regexp:[A-Za-z0-9]+"
    NIL = "nil"
    OBSOLETE_BINARY_WHOLE_NUMBER_BASE = "B"
    OBSOLETE_HEXADECIMAL_WHOLE_NUMBER_BASE = "X"
    OCTAL_WHOLE_NUMBER_BASE = "o"
    OPENING_BRACKET = "["
    // TODO remove once OPENING_PARENTHESIS is used in emptyParentheses rule
    OPENING_PARENTHESIS = "("
    // TOO remove once SEMICOLON is used in endOfExpression rule
    SEMICOLON = ";"
    // TODO remove once containers are available for `{}` after alias for empty structs
    STRUCT_OPERATOR = "%"
    TRUE = "true"
    TYPE_OPERATOR = "::"
    UNKNOWN_WHOLE_NUMBER_BASE = "regexp:A-Zac-z"
    VALID_BINARY_DIGITS = "regexp:[01]+"
    VALID_HEXADECIMAL_DIGITS = "regexp:[A-Fa-f0-9]+"
  ]
}

// expressionList is optional to handle code-less file that contains only EOL between blank lines and order comment
// lines
private elixirFile ::= endOfExpression* (expressionList endOfExpression*)?

/*
 *
 *
 * Expression List
 *
 *
 */

private infixSemicolon ::= EOL* SEMICOLON EOL*
// Must have at least one EOL or SEMICOLON, but at most one SEMICOLON
endOfExpression ::= infixSemicolon | EOL { implements = "org.elixir_lang.psi.Unquoted" }
private expression ::= emptyParentheses |
                       noParenthesesManyArgumentsCall |
                       matchedExpression
private expressionList ::= expression (endOfExpression+ expression | adjacentExpression)*

/*
 *
 *
 * Function Calls
 *
 *
 */


/* The Elixir native lexer converts Strings, CharLists and keywords (false, nil, true) to ALIAS_TOKEN/IDENTIFIER as needed.
   Elixir.flex doesn't do that, so have to list those tokens/rules that would be converted to ALIAS_TOKEN/IDENTIFIER here */
private matchedDotIdentifierOperand ::= IDENTIFIER |
                                        FALSE |
                                        NIL |
                                        TRUE |
                                        binaryString |
                                        listString


/*
 *
 * No Parentheses
 *
 */

/*
 * Many Arguments
 */

private noParenthesesCommaExpression ::= matchedExpression (infixComma noParenthesesExpression)+
/* Have to prevent matchedExpression that is actually a keywordKey from being parsed as just a matchedExpression or
   callArgumentsNoParenthesesCommaExpression COMMA EOL* callArgumentsNoParenthesesKeywords will never match. */
private noParenthesesExpression ::= emptyParentheses |
                                    /* Must be before matchedExpression because noParenthesesExpression is
                                       `matchedExpressionDotIdentifier callArgumentsNoParenthesesManyStrict`
                                       which is longer than `matchedExpressionDotIdentifier` in
                                       matchedExpression. */
                                    /* This will be marked as an error by
                                       {@link org.elixir_lang.inspection.NoParenthesesManyStrict} */
                                    noParenthesesManyStrictNoParenthesesExpression |
                                    matchedExpression !KEYWORD_PAIR_COLON
/* Special class for wrapping noParenthesesCall so that
   {@link: org.elixir_lang.inspection.NoParenthesesManyStrict} can just search for
   ElixirNoParenthesesManyStrictNoParenthesesExpression isn't of having to differentiate between valid and invalid
   ElixirNoParenthesesCall. */
noParenthesesManyStrictNoParenthesesExpression ::= noParenthesesManyArgumentsCall
/* Special class for wrapping rules so that
   {@link: org.elixir_lang.inspection.NoParenthesesStrict} can just search for
   ElixirNoParenthesesStrict instead of having to differentiate between valid and invalid
   rule classes. */
noParenthesesStrict ::= emptyParentheses |
                        OPENING_PARENTHESIS (
                                             noParenthesesKeywords |
                                             noParenthesesManyArguments
                                            ) CLOSING_PARENTHESIS

/* 1. (positional, keywords)
   2. (positional, positional)
   3. (positional, positional, keywords) */
noParenthesesManyArguments ::= matchedExpression infixComma noParenthesesKeywords |
                               noParenthesesCommaExpression (infixComma noParenthesesKeywords)?
private noParenthesesManyArgumentsStrict ::= noParenthesesManyArguments |
                                             noParenthesesStrict

noParenthesesManyArgumentsUnqualifiedCall ::= IDENTIFIER noParenthesesManyArgumentsStrict

private noParenthesesManyArgumentsQualifiedExpression ::= matchedDotExpression noParenthesesManyArgumentsQualifiedCall
left noParenthesesManyArgumentsQualifiedCall ::= infixDotOperator matchedDotIdentifierOperand noParenthesesManyArgumentsStrict

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L124-L125
private noParenthesesManyArgumentsCall ::= noParenthesesManyArgumentsQualifiedExpression | noParenthesesManyArgumentsUnqualifiedCall

/*
 * 1+ Arguments
 */

noParenthesesKeywords ::= noParenthesesKeywordsExpression (infixComma noParenthesesKeywordsExpression)*
noParenthesesKeywordsExpression ::= keywordKeyColonEOL noParenthesesExpression

/*
 * 0 Arguments
 */

left noParenthesesNoArgumentsQualifiedCall ::= infixDotOperator matchedDotIdentifierOperand
noParenthesesNoArgumentsUnqualifiedCallOrVariable ::= IDENTIFIER

/*
 *
 *
 * Heredoc
 *
 *
 */

heredocLinePrefix ::= HEREDOC_LINE_WHITE_SPACE_TOKEN? { methods = [excessWhitespace] }
heredocPrefix ::= HEREDOC_PREFIX_WHITE_SPACE?

/*
 *
 * Quote Heredocs
 *
 */

/*
 * CharList
 */

charListHeredoc ::= CHAR_LIST_HEREDOC_PROMOTER EOL
                    interpolatedCharListHeredocLine*
                    heredocPrefix CHAR_LIST_HEREDOC_TERMINATOR
                    {
                      implements = [
                        "org.elixir_lang.psi.Heredoc"
                        "org.elixir_lang.psi.InterpolatedCharList"
                        "org.elixir_lang.psi.InterpolatedCharListHeredocLined"
                        "org.elixir_lang.psi.Quote"
                      ]
                      methods = [
                        addEscapedCharacterCodePoints
                        addFragmentCodePoints
                        addHexadecimalEscapeSequenceCodePoints
                        getFragmentType
                        getHeredocLineList
                        quote
                        quoteBinary
                        quoteEmpty
                        quoteLiteral
                      ]
                      pin = 1
                    }
interpolatedCharListHeredocLine ::= heredocLinePrefix interpolatedCharListBody EOL
                                    {
                                      implements = [
                                        "org.elixir_lang.psi.CharListFragmented"
                                        "org.elixir_lang.psi.HeredocLine"
                                      ]
                                      methods = [
                                        getFragmentType
                                        getInterpolatedBody
                                        quote
                                      ]
                                    }

/*
 * String
 */

stringHeredoc ::= STRING_HEREDOC_PROMOTER EOL
                  stringHeredocLine*
                  heredocPrefix STRING_HEREDOC_TERMINATOR
                  {
                    implements = [
                      "org.elixir_lang.psi.Heredoc"
                      "org.elixir_lang.psi.InterpolatedString"
                    ]
                    methods = [
                      addEscapedCharacterCodePoints
                      addFragmentCodePoints
                      addHexadecimalEscapeSequenceCodePoints
                      getFragmentType
                      getHeredocLineList
                      quote
                      quoteBinary
                      quoteEmpty
                      quoteLiteral
                    ]
                    pin = 1
                  }
stringHeredocLine ::= heredocLinePrefix interpolatedStringBody EOL
                      {
                        implements = [
                          "org.elixir_lang.psi.HeredocLine"
                          "org.elixir_lang.psi.StringFragmented"
                        ]
                        methods = [
                          getFragmentType
                          getInterpolatedBody
                          quote
                        ]
                      }

/*
 *
 * Parent Sigil Heredocs
 *
 */

sigilModifiers ::= SIGIL_MODIFIER* { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

interpolatedCharListSigilHeredoc ::= TILDE INTERPOLATING_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_HEREDOC_PROMOTER EOL
                                     interpolatedCharListHeredocLine*
                                     heredocPrefix CHAR_LIST_SIGIL_HEREDOC_TERMINATOR sigilModifiers
                                     {
                                       implements = [
                                         "org.elixir_lang.psi.CharListFragmented"
                                         "org.elixir_lang.psi.InterpolatedCharListHeredocLined"
                                         "org.elixir_lang.psi.SigilHeredoc"
                                       ]
                                       methods = [
                                         addEscapedCharacterCodePoints
                                         addFragmentCodePoints
                                         addHexadecimalEscapeSequenceCodePoints
                                         getFragmentType
                                         getHeredocLineList
                                         quote
                                         quoteBinary
                                         quoteEmpty
                                         quoteLiteral
                                         sigilName
                                       ]
                                     }

interpolatedRegexHeredoc ::= TILDE INTERPOLATING_REGEX_SIGIL_NAME REGEX_HEREDOC_PROMOTER EOL
                             interpolatedRegexHeredocLine*
                             heredocPrefix REGEX_HEREDOC_TERMINATOR sigilModifiers
                             {
                               implements = [
                                 "org.elixir_lang.psi.RegexFragmented"
                                 "org.elixir_lang.psi.SigilHeredoc"
                               ]
                               methods = [
                                 addEscapedCharacterCodePoints
                                 addFragmentCodePoints
                                 addHexadecimalEscapeSequenceCodePoints
                                 getFragmentType
                                 getHeredocLineList
                                 quote
                                 quoteBinary
                                 quoteEmpty
                                 quoteLiteral
                                 sigilName
                               ]
                             }
interpolatedRegexHeredocLine ::= heredocLinePrefix interpolatedRegexBody EOL
                                 {
                                   implements = [
                                     "org.elixir_lang.psi.RegexFragmented"
                                     "org.elixir_lang.psi.HeredocLine"
                                   ]
                                   methods = [
                                     getFragmentType
                                     getInterpolatedBody
                                     quote
                                   ]
                                 }
interpolatedRegexBody ::= (interpolation | REGEX_FRAGMENT | escapeSequence)*
                          {
                            implements = [
                              "org.elixir_lang.psi.InterpolatedCharList"
                              "org.elixir_lang.psi.InterpolatedBody"
                            ]
                            methods = [
                              addEscapedCharacterCodePoints
                              addFragmentCodePoints
                              addHexadecimalEscapeSequenceCodePoints
                              getFragmentType
                              quote
                              quoteBinary
                              quoteEmpty
                              quoteLiteral
                            ]
                          }

private interpolatedSigilHeredoc ::= TILDE INTERPOLATING_SIGIL_NAME SIGIL_HEREDOC_PROMOTER EOL
                                     interpolatedSigilBody
                                     SIGIL_HEREDOC_PROMOTER SIGIL_MODIFIER*
private interpolatedStringSigilHeredoc ::= TILDE INTERPOLATING_STRING_SIGIL_NAME STRING_SIGIL_HEREDOC_PROMOTER EOL
                                           interpolatedStringBody
                                           STRING_SIGIL_HEREDOC_TERMINATOR
private interpolatedWordsHeredoc ::= TILDE INTERPOLATING_WORDS_SIGIL_NAME WORDS_HEREDOC_PROMOTER EOL
                                     interpolatedWordsBody
                                     WORDS_HEREDOC_TERMINATOR SIGIL_MODIFIER*

/*
 * Literal Sigil Heredocs
 */

private literalRegexHeredoc ::= TILDE LITERAL_REGEX_SIGIL_NAME REGEX_HEREDOC_PROMOTER EOL
                                literalRegexBody
                                REGEX_HEREDOC_TERMINATOR SIGIL_MODIFIER*
private literalSigilHeredoc ::= TILDE LITERAL_SIGIL_NAME SIGIL_HEREDOC_PROMOTER EOL
                                literalSigilBody
                                SIGIL_HEREDOC_TERMINATOR SIGIL_MODIFIER*
private literalStringSigilHeredoc ::= TILDE LITERAL_STRING_SIGIL_NAME STRING_SIGIL_HEREDOC_PROMOTER EOL
                                      literalStringBody
                                      STRING_SIGIL_HEREDOC_TERMINATOR
private literalWordsHeredoc ::= TILDE LITERAL_WORDS_SIGIL_NAME WORDS_HEREDOC_PROMOTER EOL
                                literalWordsBody
                                WORDS_HEREDOC_TERMINATOR SIGIL_MODIFIER*

/*
 *
 *
 * Matched Expressions - ordered by outer-most (lowest precedence) to inner-most (highest precedence)
 *
 *
 */

private matchedExpression ::= matchedNonNumericCaptureExpression

// non-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L50)
capturePrefixOperator ::= CAPTURE_OPERATOR EOL* { name = "&" }
private nonNumericCapturePrefixOperator ::= capturePrefixOperator !numeric
private matchedNonNumericCaptureExpression ::= matchedNonNumericCaptureOperation | matchedNonNumericCaptureOperand
private matchedNonNumericCaptureOperand ::= matchedNonNumericCaptureOperation | matchedMultiplicationExpression
matchedNonNumericCaptureOperation ::= nonNumericCapturePrefixOperator (noParenthesesManyArgumentsCall | matchedNonNumericCaptureOperand)

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L65)
multiplicationInfixOperator ::= EOL* MULTIPLICATION_OPERATOR EOL* { name = "*, /" }
private matchedMultiplicationExpression ::= matchedMultiplicationLeftOperand matchedMultiplicationOperation*
private matchedMultiplicationLeftOperand ::= matchedNonNumericCaptureOperation | matchedHatExpression
private matchedMultiplicationRightOperand ::= noParenthesesManyArgumentsCall | matchedMultiplicationLeftOperand
left matchedMultiplicationOperation ::= multiplicationInfixOperator matchedMultiplicationRightOperand

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L66)
hatInfixOperator ::= EOL* HAT_OPERATOR EOL* { name = "^^^" }
private matchedHatExpression ::= matchedHatLeftOperand matchedHatOperation*
private matchedHatLeftOperand ::= matchedNonNumericCaptureOperation | matchedUnaryExpression
private matchedHatRightOperand ::= noParenthesesManyArgumentsCall | matchedHatLeftOperand
left matchedHatOperation ::= hatInfixOperator matchedHatRightOperand

// non-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L67)
unaryPrefixOperator ::= (DUAL_OPERATOR | UNARY_OPERATOR) EOL* { name = "+, -, !, ^, not, ~~~" }
private matchedUnaryExpression ::= matchedUnaryOperation | matchedUnaryOperand
private matchedUnaryOperand ::= matchedNonNumericCaptureOperation | matchedUnaryOperation | matchedDotExpression
matchedUnaryOperation ::= unaryPrefixOperator (noParenthesesManyArgumentsCall | matchedUnaryOperand)

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L69)
infixDotOperator ::= EOL* DOT_OPERATOR EOL* { name = "." }
private matchedDotExpression ::= matchedDotLeftOperand (matchedDotOperation* matchedDotRightMostOperation)?
private matchedDotLeftOperand ::= matchedAtExpression
private matchedDotRightOperand ::= (
                                    ALIAS_TOKEN |
                                    IDENTIFIER |
                                    FALSE |
                                    NIL |
                                    TRUE |
                                    binaryString |
                                    listString
                                   ) &infixDotOperator
left matchedDotOperation ::= infixDotOperator matchedDotRightOperand
private matchedDotRightMostOperation ::= noParenthesesNoArgumentsQualifiedCall | qualifiedAlias
left qualifiedAlias ::= infixDotOperator ALIAS_TOKEN

// non-associative (https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L70)
atPrefixOperator ::= AT_OPERATOR EOL* { name = "@" }
private matchedAtExpression ::= matchedAtOperation | matchedAtOperand
private matchedAtOperand ::= matchedNonNumericCaptureOperation | matchedUnaryOperation | noParenthesesNoArgumentsUnqualifiedCallOrVariable | accessExpression
matchedAtOperation ::= atPrefixOperator (noParenthesesManyArgumentsCall | matchedAtOperand)

private accessExpression ::= atCharTokenOrNumberOperation |
                             captureCharTokenOrNumberOperation |
                             unaryCharTokenOrNumberOperation |
                             OPENING_PARENTHESIS infixSemicolon CLOSING_PARENTHESIS |
                             numeric |
                             list |
                             binaryString |
                             listString |
                             sigil |
                             FALSE |
                             NIL |
                             TRUE |
                             atom |
                             alias
alias ::= ALIAS_TOKEN
          { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

/*
 *
 *
 * Quotes
 *
 *
 */

/*
 * CharList
 */

interpolatedCharListBody ::= (interpolation | CHAR_LIST_FRAGMENT | escapeSequence)*
                             { implements =  "org.elixir_lang.psi.InterpolatedBody" }
charList ::= CHAR_LIST_PROMOTER
             interpolatedCharListBody
             CHAR_LIST_TERMINATOR
             {
               implements = [
                 "org.elixir_lang.psi.InterpolatedCharList"
                 "org.elixir_lang.psi.Quotable"
               ]
               methods = [
                 addEscapedCharacterCodePoints
                 addFragmentCodePoints
                 addHexadecimalEscapeSequenceCodePoints
                 getFragmentType
                 quote
                 quoteBinary
                 quoteEmpty
                 quoteLiteral
               ]
             }

/*
 * String
 */

interpolatedStringBody ::=  (interpolation | STRING_FRAGMENT | escapeSequence)*
                            { implements = "org.elixir_lang.psi.InterpolatedBody" }
string ::= STRING_PROMOTER
           interpolatedStringBody
           STRING_TERMINATOR
           {
             implements = [
               "org.elixir_lang.psi.InterpolatedString"
               "org.elixir_lang.psi.Quotable"
             ]
             methods = [
               addEscapedCharacterCodePoints
               addFragmentCodePoints
               addHexadecimalEscapeSequenceCodePoints
               getFragmentType
               quote
               quoteBinary
               quoteEmpty
               quoteLiteral
             ]
           }

/*
 *
 *
 * Whole Numbers
 *
 *
 *
 */

decimalDigits ::= INVALID_DECIMAL_DIGITS | VALID_DECIMAL_DIGITS
                  { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
decimalWholeNumber ::= decimalDigits (DECIMAL_SEPARATOR? decimalDigits)*
                        {
                          implements = "org.elixir_lang.psi.WholeNumber"
                          methods = [
                            base
                            digitsList
                            quote
                          ]
                        }

/*
 *
 * Base (Non-Decimal) Whole Numbers
 *
 */

/*
 * Binary (2)
 */

binaryDigits ::= INVALID_BINARY_DIGITS | VALID_BINARY_DIGITS
                 { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
binaryWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX (BINARY_WHOLE_NUMBER_BASE | OBSOLETE_BINARY_WHOLE_NUMBER_BASE) binaryDigits+
                     {
                       implements = "org.elixir_lang.psi.WholeNumber"
                       methods = [
                         base
                         digitsList
                         quote
                       ]
                       pin = 2
                     }

/*
 * Hexadecimal (16)
 */

hexadecimalDigits ::= INVALID_HEXADECIMAL_DIGITS | VALID_HEXADECIMAL_DIGITS
                      { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
hexadecimalWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX (HEXADECIMAL_WHOLE_NUMBER_BASE | OBSOLETE_HEXADECIMAL_WHOLE_NUMBER_BASE) hexadecimalDigits+
                           {
                             implements = "org.elixir_lang.psi.WholeNumber"
                             methods = [
                               base
                               digitsList
                               quote
                             ]
                             pin = 2
                           }

/*
 * Octal (8)
 */

octalDigits ::= INVALID_OCTAL_DIGITS | VALID_OCTAL_DIGITS
                { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
octalWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX OCTAL_WHOLE_NUMBER_BASE octalDigits+
                     {
                       implements = "org.elixir_lang.psi.WholeNumber"
                       methods = [
                         base
                         digitsList
                         quote
                       ]
                       pin = 2
                     }

/*
 *
 *
 * In alphabetical order
 *
 *
 */

// an expression in an expressionList that is NOT preceded by endOfExpression(s)
adjacentExpression ::= expression
atom ::= COLON (ATOM_FRAGMENT | quote)
         { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

private binaryString ::= string | stringHeredoc
private infixComma ::= COMMA EOL*

private containerExpression ::= emptyParentheses
decimalFloat ::= decimalWholeNumber DECIMAL_MARK decimalWholeNumber (EXPONENT_MARK DUAL_OPERATOR? decimalWholeNumber)?
// decimalFloat starts with decimalWholeNumber, so decimalFloat needs to be first
decimalNumber ::= decimalFloat |
                  decimalWholeNumber
private escapeSequence ::= hexadecimalEscapeSequence |
                           /* Must be second so that ESCAPE ('\') can be pinned in escapedCharacter without excluding
                              ("\x") in hexadecimalEscapeSequence  */
                           escapedCharacter
hexadecimalEscapeSequence ::= ESCAPE HEXADECIMAL_WHOLE_NUMBER_BASE (openHexadecimalEscapeSequence | enclosedHexadecimalEscapeSequence) { methods = [codePoint] pin = 2 }
enclosedHexadecimalEscapeSequence ::= OPENING_CURLY VALID_HEXADECIMAL_DIGITS CLOSING_CURLY
                                      { implements = "org.elixir_lang.psi.EscapedHexadecimalDigits" methods = [codePoint] pin = 1 }
openHexadecimalEscapeSequence ::= VALID_HEXADECIMAL_DIGITS
                                  { implements = "org.elixir_lang.psi.EscapedHexadecimalDigits" methods = [codePoint] }
escapedCharacter ::= ESCAPE ESCAPED_CHARACTER_TOKEN
                     { implements = "org.elixir_lang.psi.EscapeSequence" methods = [codePoint] pin = 1 }
emptyParentheses ::= OPENING_PARENTHESIS EOL* CLOSING_PARENTHESIS
private interpolatedCharListSigil ::= TILDE INTERPOLATING_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_PROMOTER interpolatedCharListBody CHAR_LIST_SIGIL_TERMINATOR


private interpolatedRegex ::= TILDE INTERPOLATING_REGEX_SIGIL_NAME REGEX_PROMOTER interpolatedRegexBody REGEX_TERMINATOR SIGIL_MODIFIER*
private interpolatedSigil ::= TILDE INTERPOLATING_SIGIL_NAME SIGIL_PROMOTER interpolatedSigilBody SIGIL_TERMINATOR SIGIL_MODIFIER*
private interpolatedSigilBody ::= (interpolation | SIGIL_FRAGMENT | escapeSequence)*
private interpolatedStringSigil ::= TILDE INTERPOLATING_STRING_SIGIL_NAME STRING_SIGIL_PROMOTER interpolatedStringBody STRING_SIGIL_TERMINATOR
private interpolatedWordsBody ::= (interpolation | WORDS_FRAGMENT | escapeSequence)*
interpolation ::= INTERPOLATION_START elixirFile INTERPOLATION_END
                  { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
keywordKey ::= ALIAS_TOKEN |
               AND_OPERATOR |
               ARROW_OPERATOR |
               ASSOCIATION_OPERATOR |
               AT_OPERATOR |
               BIT_STRING_OPERATOR |
               CAPTURE_OPERATOR |
               COMPARISON_OPERATOR |
               DUAL_OPERATOR |
               HAT_OPERATOR |
               IDENTIFIER |
               IN_MATCH_OPERATOR |
               IN_OPERATOR |
               MAP_OPERATOR |
               MATCH_OPERATOR |
               MULTIPLICATION_OPERATOR |
               OR_OPERATOR |
               PIPE_OPERATOR |
               RELATIONAL_OPERATOR |
               STAB_OPERATOR |
               STRUCT_OPERATOR |
               TUPLE_OPERATOR |
               TWO_OPERATOR |
               UNARY_OPERATOR |
               WHEN_OPERATOR |
               quote
private keywordKeyColonEOL ::= keywordKey KEYWORD_PAIR_COLON EOL*
keywordPair ::=  keywordKeyColonEOL keywordValue
keywordValue ::= containerExpression
list ::= OPENING_BRACKET EOL* (keywordPair (infixComma keywordPair)* COMMA?)? CLOSING_BRACKET
private listString ::= charList | charListHeredoc
private literalCharListBody ::= CHAR_LIST_FRAGMENT*
private literalCharListSigil ::= TILDE LITERAL_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_PROMOTER literalCharListBody CHAR_LIST_SIGIL_TERMINATOR
private literalRegex ::= TILDE LITERAL_SIGIL_NAME REGEX_PROMOTER literalRegexBody REGEX_TERMINATOR SIGIL_MODIFIER*
private literalRegexBody ::= REGEX_FRAGMENT*
private literalSigil ::= TILDE LITERAL_SIGIL_NAME SIGIL_PROMOTER literalSigilBody SIGIL_TERMINATOR SIGIL_MODIFIER*
private literalSigilBody ::= SIGIL_FRAGMENT*
private literalStringBody ::= STRING_FRAGMENT*
private literalStringSigil ::= TILDE LITERAL_STRING_SIGIL_NAME STRING_SIGIL_PROMOTER literalStringBody STRING_SIGIL_TERMINATOR
private literalWords ::=  TILDE LITERAL_SIGIL_NAME WORDS_PROMOTER literal WORDS_TERMINATOR SIGIL_MODIFIER*
private literalWordsBody ::= WORDS_FRAGMENT*

atCharTokenOrNumberOperation ::= atPrefixOperator numeric
captureCharTokenOrNumberOperation ::= capturePrefixOperator numeric
unaryCharTokenOrNumberOperation ::= unaryPrefixOperator numeric

/* elixir_tokenizer.erl converts CHAR_TOKENs to their number representation, so `number` in elixir_parser.yrl matches
   Elixir.flex's NUMBER and CHAR_TOKEN. */
private numeric ::= CHAR_TOKEN | number

//noParenthesesOneExpression ::= dotIdentifier

number ::= binaryWholeNumber |
           decimalNumber |
           hexadecimalWholeNumber |
           octalWholeNumber |
           unknownBaseWholeNumber
/*
 * Number Operations - Used in accessExpression
 */

private quote ::= (charList | string)
private sigil ::= interpolatedCharListSigil |
                  interpolatedCharListSigilHeredoc |
                  interpolatedRegexHeredoc |
                  interpolatedSigilHeredoc |
                  interpolatedStringSigilHeredoc |
                  interpolatedWordsHeredoc |
                  interpolatedRegex |
                  interpolatedSigil |
                  interpolatedStringSigil |
                  literalCharListSigil |
                  literalRegexHeredoc |
                  literalSigilHeredoc |
                  literalStringSigilHeredoc |
                  literalWordsHeredoc |
                  literalRegex |
                  literalSigil |
                  literalStringSigil |
                  literalWords

unknownBaseWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX UNKNOWN_WHOLE_NUMBER_BASE INVALID_UNKNOWN_BASE_DIGITS+ { pin=2 }
